#include <Arduino.h>
#include <WiFi.h>
#include <Preferences.h>
#include <Firebase_ESP_Client.h>
#include <ESP32Servo.h>
#include <time.h>
#include <HX711.h>
#include <HardwareSerial.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

// ========== USER CONFIGURATION ==========
#define FIREBASE_PROJECT_ID "pawfeeds-v2"
#define FIREBASE_DATABASE_URL "https://pawfeeds-v2-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define SERVICE_ACCOUNT_CLIENT_EMAIL "firebase-adminsdk-fbsvc@pawfeeds-v2.iam.gserviceaccount.com"
#define SERVICE_ACCOUNT_PRIVATE_KEY "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC+Sqt8BKfCEgbp\n/q4XmzzpsKwlsKJesbWN/Sp2PO7nVgPqwEz9YeCy/aI98IjyGY5hujaLLNgB0GYE\nNLvWkAf3T6VQPUa8SB28XU5sT7tfCJu/1F3yYYAVHHpbg2gbGxjgPWVlQ5arww57\nHHREzOUTRTO5k9hRAzzf1kdjBJbboewEEcIQH2uAdn+B9L58SOezjVONpr63+R5V\nWbZ7+B64BFE62Xsjcmk49OmHjKc+2ID80S6EWx6rxM5jGdTsUVtA0RISG5r1qeB/\nDazLCx1jexutuMHTogvAIirHGIMdOCW12USD8b+CRvP7Lsj6CwR91JSVm/b5P1pI\n0MNAgkfrAgMBAAECggEAO5iNHlki5P/aVHxjr5b5u8KOF3u7TmbfkmmAW+l3dNIW\nhfXV5uE5izUuE7H6YcApPGgiXvIbcG4BFT4iue7/3698+aVHOv5m+bBLOFa8OuYq\nSSjMh3WLtJDnrTN5bkvNPaVc1RsW3BJJvbrKmyWEdMWOjodEDxMxhHTKhLNSP9Rq\ncTz85kc4/IsXuAD6fmApysrWiVuS+vcIzFGCjqQDozojsd58KW6XFa8PEZ95bUbE\n/Q8ZAigB88un8+87NpLd/usUk2FWHNJz523AJUA4qQE0N8J6E/7+dJbRJ9Ucg6lk\nkO0fRiLO7c7o6/7bW1iy4Yq+ph5N3+vc2pYzVZIkAQKBgQD0AbH86UoJxroGh/id\n849814dnEGugSQ1C2XCPNpQy19WtyfZvMM5yphfxfxxohJwr+KyQBcfBatGo/ipV\n9cIJUOalKa+q9KzxLsSka41cvu4RsnVjWyVqGS4w/BdYFdTvNkuK3cGiK8qYwBaW\ni50PNrcCQ+7gmMCjkPJ6LDOh6wKBgQDHpRYRXk9ipsOw4KHBxn4rph8G6ooUIvzs\nPie0e+A+pz9grNDC7y0a+k8fA4eq/iJPmu+FvuJW4fahCkt98VuW0EJjcqtBNgCB\nYbOKn9H+V4WaQKCHYyhl/QxGio4qm4z34cEVt/kMGwGHlaX39RILc3kEq2RfTSc7\n2FikgZxyAQKBgQCz61wWpN5W/xXEIxaLQUCYSUQqFs2FTthcZoC82P3Fz6hbkQQJ\nUO+pUhdtltCXsNCHC8ISIHD+iYk3FtKYt7HvtJudRXOmluu+m0GcC0IdFRvuKKyu\nKlMYPKD2tatw5AgyqtJg/sr8jVXB9EGzmBajVTD0lqrZKUlCUmq480bPKQKBgQCp\nTo0qaYp1JOur4rQK+uQg7B4/5UL31LwdNJDDdJI1T+xldekMh3z+9euHZ5z0G9TJ\nIaGjEMAt4i8fXvWqdravbSn/4EzvXnaLQmnaU7LoORzqNYhtiF/ILhLs96+c3pFr\n3h2652vjIjvn2bcIUuLcpy6oERlr4Kg3DkAOMoSUAQKBgQCkTg6e4Ndg1d2SySFQ\n4h7YHQZ3larxK/03DFoElNIf/6zgiNL13+9nM3l4K8YAEG1OEcn5JaBdktmGrEWR\nA+zV7Qp/hZSVuOM4sxpGa7q94A5253tvLvegIvzhFYW4WQrVFadI5xZ1HaO2Ad9I\nKzz19+jbd085r+kyTM5X0UVzZA==\n-----END PRIVATE KEY-----\n"

#define SERVO_BOWL_1_PIN 21
#define SERVO_BOWL_2_PIN 22
#define HX711_BOWL1_DOUT_PIN 27
#define HX711_BOWL1_SCK_PIN 26
#define HX711_BOWL2_DOUT_PIN 19
#define HX711_BOWL2_SCK_PIN 18

// --- RFID PINS ---
#define RFID1_RX_PIN 16
#define RFID1_TX_PIN 17
#define RFID2_RX_PIN 4
#define RFID2_TX_PIN 2

#define SLAVE_1_SERIAL_TX_PIN 33
#define SLAVE_1_SERIAL_RX_PIN 32
#define SLAVE_2_SERIAL_TX_PIN 15
#define SLAVE_2_SERIAL_RX_PIN 14

#define DISPENSE_MS_PER_GRAM 50
const char* AP_SSID = "PawFeeds_Setup";
const char* AP_PASSWORD = NULL;

#define CALIBRATION_FACTOR_1 -350.0
#define CALIBRATION_FACTOR_2 -350.0

// [MODIFIED] Max weight set to 800
#define MAX_WEIGHT_GRAMS 1000.0

// [NEW] Threshold to trigger a "refill" event (Detects 100g of ADDED food)
#define REFILL_THRESHOLD_GRAMS 100.0

// --- Global Objects ---
WiFiServer server(80);
Preferences preferences;
FirebaseData stream_fbdo;
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;
Servo servoBowl1;
Servo servoBowl2;
HX711 loadCellBowl1;
HX711 loadCellBowl2;
HardwareSerial SerialRFID1(1);
HardwareSerial SerialRFID2(2);
String feederId = "";
String streamPath = "/commands/";
bool streamActive = false;
unsigned long lastCmdTimestamp = 0;
unsigned long lastWeightUpdateTime = 0;

// ============================================
// --- FAKE WEIGHT VARIABLES (PRESENTATION) ---
// ============================================
float fakeWeightBowl1 = 1000.0;
float fakeWeightBowl2 = 0;

// [NEW] Tracking real sensor values to detect refills
float lastRealWeight1 = 0;
float lastRealWeight2 = 0;
unsigned long lastRefillCheck = 0;

// --- MULTI-BOWL STATE MANAGEMENT (Scheduling) ---
struct BowlWaitState {
    bool active;
    String expectedTag;
    int amount;
    String scheduleId;
    String petId;
    unsigned long waitStartTime;
};
// Independent states for concurrency
BowlWaitState bowl1State = {false, "", 0, "", "", 0};
BowlWaitState bowl2State = {false, "", 0, "", "", 0};

// --- NON-BLOCKING DISPENSER MANAGEMENT ---
struct DispenserState {
    bool isDispensing;
    unsigned long startTime;
    unsigned long duration;
    Servo* servo;
    int bowlId;
    int amountToDispense; // [ADDED] To subtract from fake weight
};
DispenserState dispenser1 = {false, 0, 0, &servoBowl1, 1, 0};
DispenserState dispenser2 = {false, 0, 0, &servoBowl2, 2, 0};

// --- Global Modes ---
enum GlobalMode { NORMAL, PAIRING };
GlobalMode globalMode = NORMAL;
int pairingBowlTarget = 0;
unsigned long pairingStartTime = 0;

// --- Buffers ---
String rfid1_buffer = "";
String rfid2_buffer = "";
unsigned long lastRfid1ByteTime = 0;
unsigned long lastRfid2ByteTime = 0;
const long rfidTagTimeout = 50;
String lastScannedTag = "";
unsigned long lastLogTime = 0;

volatile bool newCommandAvailable = false;
volatile bool clearCommandNode = false;
struct Command {
    int bowl;
    int amount;
};
Command pendingCommand;
// --- Status Update Queue ---
struct StatusUpdatePacket {
    int bowl;
    bool isWaiting;
    int amount;
    String petId;
};
volatile bool statusUpdateAvailable = false;
StatusUpdatePacket statusUpdateQueue;
enum DeviceState {
    PROVISIONING_MODE,
    CONNECTING_WIFI,
    SYNCING_TIME,
    SYNCING_TIME_HTTP_FALLBACK, 
    AUTHENTICATING_FIREBASE,
    REGISTERING_FIREBASE,
    OPERATIONAL,
    RESETTING,
    ERROR
};
DeviceState currentState = PROVISIONING_MODE;

// --- Function Prototypes ---
void tokenStatusCallback(TokenInfo info);
void connectToWiFi();
void syncTime();
void syncTimeWithHttpFallback();
void authenticateWithFirebase();
void registerDeviceWithFirestore();
void startProvisioningServer();
void handleClient();
String urlDecode(String str);
String parseFeederIdFromResponse(String response);
void triggerDispense(int bowl, int amount);
void handleDispensers();
void processPendingCommand();
void startRTDBStream();
void streamCallback(FirebaseStream data);
void streamTimeoutCallback(bool timeout);
void forwardSlaveLogs();
bool sendToSlave(HardwareSerial& serial, const String& packet);
void forwardPacketToSlaves(const String& packet, const String& packetType);
void updateFoodLevelsInFirestore();
float getWeightInGrams(HX711& sensor, int sensorNum); // [RENAMED]
void updateRfidBuffers();
void handleRfidRead(int readerNum, String scannedTagId);
void checkRfidTimeouts();
void updateBowlStatus(int bowl, bool isWaiting, int amount, String petId);
void checkRefills(); // [NEW]

void forwardPacketToSlaves(const String& packet, const String& packetType) {
    Serial.printf("[PROVISIONING] Forwarding %s to slave cameras...\n", packetType.c_str());
    SerialRFID1.end(); 
    SerialRFID2.end();
    delay(50);

    Serial.println("[PROVISIONING] Contacting Slave 1...");
    Serial2.begin(9600, SERIAL_8N1, SLAVE_1_SERIAL_RX_PIN, SLAVE_1_SERIAL_TX_PIN);
    if (sendToSlave(Serial2, packet)) {
        Serial.printf("[PROVISIONING] %s sent to Slave 1 successfully.\n", packetType.c_str());
    } else {
        Serial.printf("[ERROR] Failed to send %s to Slave 1.\n", packetType.c_str());
    }
    Serial2.end(); 
    delay(200);

    Serial.println("[PROVISIONING] Contacting Slave 2...");
    Serial1.begin(9600, SERIAL_8N1, SLAVE_2_SERIAL_RX_PIN, SLAVE_2_SERIAL_TX_PIN);
    if (sendToSlave(Serial1, packet)) {
        Serial.printf("[PROVISIONING] %s sent to Slave 2 successfully.\n", packetType.c_str());
    } else {
        Serial.printf("[ERROR] Failed to send %s to Slave 2.\n", packetType.c_str());
    }
    Serial1.end(); 
    
    Serial.println("[PROVISIONING] Forwarding complete.");
    
    SerialRFID1.begin(9600, SERIAL_8N1, RFID1_RX_PIN, RFID1_TX_PIN);
    SerialRFID2.begin(9600, SERIAL_8N1, RFID2_RX_PIN, RFID2_TX_PIN);
}

void setup() {
    Serial.begin(115200);
    Serial.println("\n[PawFeeds] Booting...");
    servoBowl1.attach(SERVO_BOWL_1_PIN);
    servoBowl2.attach(SERVO_BOWL_2_PIN);
    
    servoBowl1.write(90);
    servoBowl2.write(90);

    Serial.println("[HX711] Initializing weight sensor 1...");
    loadCellBowl1.begin(HX711_BOWL1_DOUT_PIN, HX711_BOWL1_SCK_PIN);
    loadCellBowl1.set_scale(CALIBRATION_FACTOR_1);
    loadCellBowl1.tare();

    Serial.println("[HX711] Initializing weight sensor 2...");
    loadCellBowl2.begin(HX711_BOWL2_DOUT_PIN, HX711_BOWL2_SCK_PIN);
    loadCellBowl2.set_scale(CALIBRATION_FACTOR_2);
    loadCellBowl2.tare();
    Serial.println("[HX711] Ready. Please fill food containers now.");
    
    // [NEW] Initialize real weight tracking
    Serial.println("[SYSTEM] Calibrating refill detection baseline...");
    lastRealWeight1 = loadCellBowl1.get_units(5);
    lastRealWeight2 = loadCellBowl2.get_units(5);

    delay(2000); // Slight delay to ensure stability

    Serial.println("[RFID] Initializing RFID reader 1 (Bowl 1)...");
    SerialRFID1.begin(9600, SERIAL_8N1, RFID1_RX_PIN, RFID1_TX_PIN);
    Serial.println("[RFID] Initializing RFID reader 2 (Bowl 2)...");
    SerialRFID2.begin(9600, SERIAL_8N1, RFID2_RX_PIN, RFID2_TX_PIN);

    preferences.begin("pawfeeds", false);
    
    
    if (preferences.getString("ssid", "").length() > 0) {
        currentState = CONNECTING_WIFI;
    } else {
        currentState = PROVISIONING_MODE;
        startProvisioningServer();
    }
}

void loop() {
    forwardSlaveLogs();

    if (currentState == OPERATIONAL) {
        updateRfidBuffers();
        checkRfidTimeouts();
        handleDispensers(); 
        checkRefills(); // [NEW] Check if food was poured
    }

    switch (currentState) {
        case PROVISIONING_MODE:
            handleClient();
            break;
        case CONNECTING_WIFI:
            connectToWiFi();
            break;
        case SYNCING_TIME:
            syncTime();
            break;
        case SYNCING_TIME_HTTP_FALLBACK: 
            syncTimeWithHttpFallback();
            break;
        case AUTHENTICATING_FIREBASE:
            authenticateWithFirebase();
            break;
        case REGISTERING_FIREBASE:
            registerDeviceWithFirestore();
            break;
        case OPERATIONAL:
            if (!streamActive) {
                startRTDBStream();
            }
            if (Firebase.ready() && !Firebase.RTDB.readStream(&stream_fbdo)) {
                Serial.println("[ERROR] Stream read error!");
                streamActive = false;
            }

            if (statusUpdateAvailable) {
                updateBowlStatus(statusUpdateQueue.bowl, statusUpdateQueue.isWaiting, statusUpdateQueue.amount, statusUpdateQueue.petId);
                statusUpdateAvailable = false;
            }

            if (newCommandAvailable) {
                processPendingCommand();
                newCommandAvailable = false;
            }

            if (clearCommandNode) {
                Serial.println("[SYSTEM] Clearing command node from main loop.");
                String fullStreamPath = streamPath;
                fullStreamPath.concat(feederId);
                
                fbdo.clear();
                if (Firebase.RTDB.setString(&fbdo, fullStreamPath.c_str(), "null")) {
                    Serial.println("[SYSTEM] Command node cleared successfully.");
                } else {
                    Serial.printf("[SYSTEM] FAILED to clear command node: %s\n", fbdo.errorReason().c_str());
                }
                clearCommandNode = false;
            }

            if (millis() - lastWeightUpdateTime > 300000) { 
                Serial.println("[SYSTEM] Time to update weight levels...");
                updateFoodLevelsInFirestore();
                lastWeightUpdateTime = millis();
            }
            break;
        case RESETTING:
            streamActive = false;
            Serial.println("[RESET] Entered RESETTING state. Network tasks stopped.");
            forwardPacketToSlaves("RESET_DEVICE\n", "RESET COMMAND");
            Serial.println("[RESET] Waiting for slaves...");
            delay(3000);
            Serial.println("[RESET] Wiping Master credentials and rebooting...");
            preferences.clear();
            ESP.restart();
            break;

        case ERROR:
            Serial.println("[ERROR] Error state reached. Restarting system in 10 seconds...");
            delay(10000);
            ESP.restart();
            break;
    }
    delay(10);
}

// [UPDATED] Refill Detection Logic
void checkRefills() {
    if (millis() - lastRefillCheck > 500) { // Check every 500ms
        lastRefillCheck = millis();
        
        // --- CHECK BOWL 1 ---
        float currentReal1 = loadCellBowl1.get_units(1); 
        
        // LOGIC: Only trigger refill if FAKE weight is LOW (<= 100g)
        if (fakeWeightBowl1 <= 100.0) {
            if (currentReal1 > lastRealWeight1 + REFILL_THRESHOLD_GRAMS) {
                Serial.printf("[SYSTEM] Low Food Refill Detected on Bowl 1! (Delta: +%.1fg). Resetting Fake Weight.\n", currentReal1 - lastRealWeight1);
                fakeWeightBowl1 = MAX_WEIGHT_GRAMS; 
                updateFoodLevelsInFirestore(); 
            }
        }
        // Always track the real weight so we know when a pour happens, 
        // even if we ignored it because the bowl was full.
        lastRealWeight1 = currentReal1;

        // --- CHECK BOWL 2 ---
        float currentReal2 = loadCellBowl2.get_units(1);
        
        if (fakeWeightBowl2 <= 100.0) {
            if (currentReal2 > lastRealWeight2 + REFILL_THRESHOLD_GRAMS) {
                Serial.printf("[SYSTEM] Low Food Refill Detected on Bowl 2! (Delta: +%.1fg). Resetting Fake Weight.\n", currentReal2 - lastRealWeight2);
                fakeWeightBowl2 = MAX_WEIGHT_GRAMS; 
                updateFoodLevelsInFirestore();
            }
        }
        lastRealWeight2 = currentReal2;
    }
}

void tokenStatusCallback(TokenInfo info) {
    if (info.status == token_status_ready) {
        Serial.println("[AUTH] Token obtained successfully.");
    } else if (info.status == token_status_error) {
        Serial.printf("[AUTH] Token error: %s\n", info.error.message.c_str());
    }
}

void connectToWiFi() {
    Serial.println("[WIFI] Connecting...");
    WiFi.begin(preferences.getString("ssid").c_str(), preferences.getString("pass").c_str());
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 30) {
        delay(500);
        Serial.print(".");
        attempts++;
    }

    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\n[WIFI] Connected!");
        currentState = SYNCING_TIME;
    } else {
        Serial.println("\n[WIFI] Failed! Retrying...");
        delay(2000);
    }
}

void syncTime() {
    Serial.println("[TIME] Syncing with NTP server...");
    configTime(8 * 3600, 0, "pool.ntp.org", "time.nist.gov", "time.google.com");
    time_t now = time(nullptr);
    int attempts = 0;
    while (now < 8 * 3600 * 2 && attempts < 30) {
        delay(500);
        now = time(nullptr);
        attempts++;
    }

    if (now < 8 * 3600 * 2) {
        Serial.println("[TIME] Failed to sync time via NTP!");
        Serial.println("[TIME] Attempting HTTP time fallback...");
        currentState = SYNCING_TIME_HTTP_FALLBACK;
    } else {
        struct tm timeinfo;
        gmtime_r(&now, &timeinfo);
        Serial.print("[TIME] Time synced successfully via NTP: ");
        Serial.print(asctime(&timeinfo));
        currentState = AUTHENTICATING_FIREBASE;
    }
}

void syncTimeWithHttpFallback() {
    Serial.println("[TIME_HTTP] Fetching time from World Time API...");
    HTTPClient http;
    if (!http.begin("http://worldtimeapi.org/api/ip")) {
        Serial.println("[TIME_HTTP] Failed to begin HTTP client. Retrying NTP...");
        delay(3000);
        currentState = SYNCING_TIME; 
        return;
    }

    int httpCode = http.GET();
    if (httpCode > 0) {
        if (httpCode == HTTP_CODE_OK) {
            String payload = http.getString();
            DynamicJsonDocument doc(1024);
            DeserializationError error = deserializeJson(doc, payload);
            if (error) {
                Serial.print(F("[TIME_HTTP] deserializeJson() failed: "));
                Serial.println(error.f_str());
                delay(3000);
                currentState = SYNCING_TIME; 
            } else {
                if (doc.containsKey("unixtime")) {
                    time_t now = doc["unixtime"];
                    struct timeval tv;
                    tv.tv_sec = now;
                    tv.tv_usec = 0;
                    settimeofday(&tv, NULL);

                    struct tm timeinfo;
                    gmtime_r(&now, &timeinfo);
                    Serial.print("[TIME_HTTP] Time synced successfully via HTTP: ");
                    Serial.print(asctime(&timeinfo));
                    currentState = AUTHENTICATING_FIREBASE;
                } else {
                      Serial.println("[TIME_HTTP] 'unixtime' field not found. Retrying NTP...");
                      delay(3000);
                      currentState = SYNCING_TIME; 
                }
            }
        } else {
            Serial.printf("[TIME_HTTP] GET request failed, error: %s. Retrying NTP...\n", http.errorToString(httpCode).c_str());
            delay(3000);
            currentState = SYNCING_TIME; 
        }
    } else {
        Serial.printf("[TIME_HTTP] GET request failed, error: %s. Retrying NTP...\n", http.errorToString(httpCode).c_str());
        delay(3000);
        currentState = SYNCING_TIME; 
    }
    http.end();
}

void authenticateWithFirebase() {
    static bool config_initiated = false;
    static unsigned long authStartTime = 0;

    if(Firebase.ready()) {
        Serial.println("[AUTH] Authenticated!");
        feederId = preferences.getString("feederId", "");
        if(feederId.length() > 0) {
            currentState = OPERATIONAL;
        } else {
            currentState = REGISTERING_FIREBASE;
        }
        config_initiated = false; 
        return;
    }

    if (!config_initiated) {
        Serial.println("[AUTH] Configuring service account (One-time init)...");
        config.database_url = FIREBASE_DATABASE_URL;
        config.service_account.data.client_email = SERVICE_ACCOUNT_CLIENT_EMAIL;
        config.service_account.data.project_id = FIREBASE_PROJECT_ID;
        config.service_account.data.private_key = SERVICE_ACCOUNT_PRIVATE_KEY;
        config.token_status_callback = tokenStatusCallback;
        // SAFE BUFFERS
        stream_fbdo.setBSSLBufferSize(4096 /* Rx */, 1024 /* Tx */);
        fbdo.setBSSLBufferSize(2048 /* Rx */, 1024 /* Tx */);
        
        // [FIX] Increased timeouts for slow connections
        config.timeout.socketConnection = 60000; // Increased from 30s
        config.timeout.serverResponse = 40000;   // Increased from 10s
        config.timeout.wifiReconnect = 10000;
        
        Firebase.reconnectWiFi(true);
        Serial.printf("[AUTH] Free Heap Before Begin: %d\n", ESP.getFreeHeap());
        Firebase.begin(&config, &auth);
        
        config_initiated = true;
        authStartTime = millis();
        Serial.println("[AUTH] Firebase.begin() called. Waiting for token...");
    } else {
        if (millis() - authStartTime > 60000) {
            Serial.println("[AUTH] TIMEOUT waiting for token! Resetting ESP to clear SSL stack.");
            delay(1000);
            ESP.restart();
        }
        
        static unsigned long lastPrint = 0;
        if (millis() - lastPrint > 1000) {
            Serial.print(".");
            lastPrint = millis();
        }
    }
}

void registerDeviceWithFirestore() {
    if (!Firebase.ready()) {
        Serial.println("[FIREBASE] Waiting for auth token...");
        return;
    }

    Serial.println("[FIREBASE] Registering device...");
    String owner_uid = preferences.getString("owner_uid", "");
    if (owner_uid.length() == 0) {
        Serial.println("[ERROR] No Owner UID found. Returning to Provisioning.");
        currentState = PROVISIONING_MODE;
        startProvisioningServer();
        return;
    }

    FirebaseJson content;
    content.set("fields/owner_uid/stringValue", owner_uid);
    content.set("fields/online/booleanValue", true);

    float initialWeight1 = getWeightInGrams(loadCellBowl1, 1);
    float initialWeight2 = getWeightInGrams(loadCellBowl2, 2);
    int initialWeight1_int = (int)initialWeight1;
    int initialWeight2_int = (int)initialWeight2;
    content.set("fields/foodLevels/mapValue/fields/1/integerValue", initialWeight1_int);
    content.set("fields/foodLevels/mapValue/fields/2/integerValue", initialWeight2_int);

    String feederContent;
    content.toString(feederContent, false);
    
    fbdo.clear();
    if (Firebase.Firestore.createDocument(&fbdo, FIREBASE_PROJECT_ID, "", "feeders", feederContent.c_str())) {
        Serial.println("[FIREBASE] Feeder document created.");
        feederId = parseFeederIdFromResponse(fbdo.payload());
        if (feederId.length() > 0) {
            preferences.putString("feederId", feederId);
            String feederIdPacket = "FEEDER_ID|";
            feederIdPacket.concat(feederId);
            feederIdPacket.concat("\n");
            forwardPacketToSlaves(feederIdPacket, "Feeder ID");

            String usersPath = "users/";
            usersPath.concat(owner_uid);

            FirebaseJson userUpdateContent;
            userUpdateContent.set("fields/feederId/stringValue", feederId);
            String userContent;
            userUpdateContent.toString(userContent, false);
            
            fbdo.clear();
            if (Firebase.Firestore.patchDocument(&fbdo, FIREBASE_PROJECT_ID, "", usersPath.c_str(), userContent.c_str(), "feederId")) {
                Serial.println("[FIREBASE] User patched. Setup complete!");
                String setupSyncPath = "/setup_sync/";
                setupSyncPath.concat(owner_uid);
                
                FirebaseJson syncJson;
                syncJson.set("status", "complete");
                syncJson.set("feederId", feederId);
                
                fbdo.clear();
                if(Firebase.RTDB.setJSON(&fbdo, setupSyncPath.c_str(), &syncJson)) {
                      Serial.println("[RTDB] Setup completion signal sent to App.");
                } else {
                      Serial.printf("[RTDB] Failed to send setup signal: %s\n", fbdo.errorReason().c_str());
                }

                currentState = OPERATIONAL;
            } else {
                Serial.printf("[ERROR] Failed to patch user: %s. Retrying...\n", fbdo.errorReason().c_str());
                delay(2000);
            }
        } else {
            Serial.println("[ERROR] Failed to parse feeder ID. Retrying...");
            delay(2000);
        }
    } else {
        Serial.printf("[ERROR] Failed to create feeder doc: %s. Retrying...\n", fbdo.errorReason().c_str());
        delay(2000);
    }
}

void startProvisioningServer() {
    Serial.print("[PROVISIONING] Starting Access Point: ");
    Serial.println(AP_SSID);
    WiFi.softAP(AP_SSID, AP_PASSWORD);
    IPAddress IP = WiFi.softAPIP();
    Serial.print("[PROVISIONING] AP IP address: ");
    Serial.println(IP.toString());
    server.begin();
    Serial.println("[PROVISIONING] Web server started.");
}

void handleClient() {
    WiFiClient client = server.available();
    if (!client) return;
    String currentLine = "";
    unsigned long timeout = millis();
    String header = "";
    while (client.connected() && millis() - timeout < 2000) {
        if (client.available()) {
            char c = client.read();
            header += c;
            if (c == '\n') {
                if (currentLine.length() == 0) {
                    if (header.indexOf("GET /networks") >= 0) {
                        int n = WiFi.scanNetworks();
                        String json = "[";
                        for (int i = 0; i < n; ++i) {
                            if (i > 0) json.concat(",");
                            json.concat("{\"ssid\":\"");
                            json.concat(WiFi.SSID(i));
                            json.concat("\",\"rssi\":");
                            json.concat(WiFi.RSSI(i));
                            json.concat("}");
                        }
                        json += "]";
                        client.println("HTTP/1.1 200 OK");
                        client.println("Content-type:application/json");
                        client.println("Connection: close");
                        client.println();
                        client.println(json);
                    } else if (header.indexOf("POST /save") >= 0) {
                        String body;
                        while (client.available()) { body += (char)client.read(); }
                        int ssid_start = body.indexOf("ssid=") + 5;
                        int ssid_end = body.indexOf("&", ssid_start);
                        String ssid = urlDecode(body.substring(ssid_start, ssid_end));
                        int pass_start = body.indexOf("pass=") + 5;
                        int pass_end = body.indexOf("&", pass_start);
                        String pass = urlDecode(body.substring(pass_start, pass_end));
                        int uid_start = body.indexOf("uid=") + 4;
                        String uid = urlDecode(body.substring(uid_start));
                        preferences.putString("ssid", ssid);
                        preferences.putString("pass", pass);
                        preferences.putString("owner_uid", uid);

                        String credentialsPacket = ssid;
                        credentialsPacket.concat("|");
                        credentialsPacket.concat(pass);
                        credentialsPacket.concat("\n");
                        forwardPacketToSlaves(credentialsPacket, "Credentials");

                        client.println("HTTP/1.1 200 OK\r\nContent-type:text/html\r\n\r\n<h1>Saved! Restarting...</h1>");
                        delay(1500);
                    }
                    break;
                } else {
                    currentLine = "";
                }
            } else if (c != '\r') {
                currentLine += c;
            }
        }
    }
    client.stop();
    if (header.indexOf("POST /save") >= 0) {
        Serial.println("[PROVISIONING] Credentials saved. Restarting device.");
        ESP.restart();
    }
}

String parseFeederIdFromResponse(String response) {
    FirebaseJson json;
    json.setJsonData(response);
    FirebaseJsonData result;
    if (json.get(result, "name")) {
        String path = result.to<String>();
        int lastSlash = path.lastIndexOf('/');
        if (lastSlash != -1) {
            return path.substring(lastSlash + 1);
        }
    }
    return "";
}

String urlDecode(String str) {
    String decodedString = "";
    char temp[] = "0x00";
    char c;
    for (size_t i = 0; i < str.length(); i++) {
        c = str.charAt(i);
        if (c == '+') {
            decodedString += ' ';
        } else if (c == '%') {
            i++;
            temp[2] = str.charAt(i);
            i++;
            temp[3] = str.charAt(i);
            decodedString += (char)strtol(temp, NULL, 16);
        } else {
            decodedString += c;
        }
    }
    return decodedString;
}

void processPendingCommand() {
    if (pendingCommand.amount > 0 && pendingCommand.bowl > 0) {
        Serial.printf("[COMMAND] Processing FEED NOW command! Bowl: %d, Amount: %d\n", pendingCommand.bowl, pendingCommand.amount);
        triggerDispense(pendingCommand.bowl, pendingCommand.amount);
        clearCommandNode = true;
    }
}

// ==========================================================
// --- NON-BLOCKING DISPENSER LOGIC ---
// ==========================================================

void triggerDispense(int bowlNumber, int amount) {
    long duration = amount * DISPENSE_MS_PER_GRAM;
    Serial.printf("[SERVO] Triggering dispense for Bowl %d (Duration: %ld ms)\n", bowlNumber, duration);
    if (bowlNumber == 1) {
        if (!dispenser1.isDispensing) {
            dispenser1.isDispensing = true;
            dispenser1.startTime = millis();
            dispenser1.duration = duration;
            dispenser1.amountToDispense = amount; // Store amount to fake subtract later
            dispenser1.servo->write(0); // Open
        }
    } 
    else if (bowlNumber == 2) {
        if (!dispenser2.isDispensing) {
            dispenser2.isDispensing = true;
            dispenser2.startTime = millis();
            dispenser2.duration = duration;
            dispenser2.amountToDispense = amount; // Store amount to fake subtract later
            dispenser2.servo->write(0); // Open
        }
    }
}

void handleDispensers() {
    unsigned long currentMillis = millis();
    // Check Bowl 1
    if (dispenser1.isDispensing) {
        if (currentMillis - dispenser1.startTime > dispenser1.duration) {
            dispenser1.servo->write(90);
            // Close
            dispenser1.isDispensing = false;
            
            // [FAKE] Subtract weight
            fakeWeightBowl1 -= dispenser1.amountToDispense;
            if(fakeWeightBowl1 < 0) fakeWeightBowl1 = 0;
            
            Serial.printf("[SERVO] Bowl 1 Dispense Complete. Fake Weight: %.0f\n", fakeWeightBowl1);
            updateFoodLevelsInFirestore();
            }
    }

    // Check Bowl 2
    if (dispenser2.isDispensing) {
        if (currentMillis - dispenser2.startTime > dispenser2.duration) {
            dispenser2.servo->write(90);
            // Close
            dispenser2.isDispensing = false;
            
            // [FAKE] Subtract weight
            fakeWeightBowl2 -= dispenser2.amountToDispense;
            if(fakeWeightBowl2 < 0) fakeWeightBowl2 = 0;
            
            Serial.printf("[SERVO] Bowl 2 Dispense Complete. Fake Weight: %.0f\n", fakeWeightBowl2);
            updateFoodLevelsInFirestore();
        }
    }
}

// === Helper to update status in RTDB ===
void updateBowlStatus(int bowl, bool isWaiting, int amount, String petId) {
    if (feederId.length() == 0) return;
    String path = "/feeders/";
    path += feederId;
    path += "/bowlStatus/";
    path += bowl;
    
    FirebaseJson json;
    json.set("isWaiting", isWaiting);
    if (isWaiting) {
        json.set("amount", amount);
        json.set("petId", petId);
    } else {
        json.set("amount", 0);
        json.set("petId", "");
    }
    fbdo.clear();
    if(Firebase.RTDB.setJSON(&fbdo, path.c_str(), &json)) {
        // Log optional
    }
}

void startRTDBStream() {
    if (feederId.length() == 0 || !Firebase.ready()) return;
    String statusPath = "/feeders/";
    statusPath += feederId;
    statusPath += "/status";

    Serial.println("[PRESENCE] Setting status to online...");
    fbdo.clear();
    if (Firebase.RTDB.setString(&fbdo, statusPath.c_str(), "online")) {
        Serial.println("[PRESENCE] Status set to online.");
    } else {
        Serial.printf("[PRESENCE] Failed to set online status: %s\n", fbdo.errorReason().c_str());
    }

    String fullStreamPath = streamPath;
    fullStreamPath.concat(feederId);
    Serial.print("[STREAM] Starting stream on path: ");
    Serial.println(fullStreamPath);
    
    stream_fbdo.clear();
    if (!Firebase.RTDB.beginStream(&stream_fbdo, fullStreamPath.c_str())) {
        Serial.printf("[STREAM] Could not begin stream: %s\n", stream_fbdo.errorReason().c_str());
        return;
    }
    Firebase.RTDB.setStreamCallback(&stream_fbdo, streamCallback, streamTimeoutCallback);
    streamActive = true;
    Serial.println("[STREAM] Stream started successfully.");
}

void streamCallback(FirebaseStream data) {
    Serial.printf("[STREAM] Event: %s, Path: %s, Data: %s\n", data.eventType().c_str(), data.dataPath().c_str(), data.payload().c_str());
    if (data.dataType() == "json" && data.dataPath() == "/") {
        FirebaseJson json;
        json.setJsonData(data.payload());
        FirebaseJsonData result;

        String command;
        if (json.get(result, "command")) {
            command = result.to<String>();
        }

        if (command == "feed") {
            unsigned long newTimestamp = 0;
            int bowl = 0;
            int amount = 0;
            if (json.get(result, "timestamp")) newTimestamp = result.to<unsigned long>();
            if (json.get(result, "bowl")) bowl = result.to<int>();
            if (json.get(result, "amount")) amount = result.to<int>();
            if (newTimestamp > 0 && newTimestamp >= lastCmdTimestamp) {
                lastCmdTimestamp = newTimestamp;
                pendingCommand = {bowl, amount};
                newCommandAvailable = true;
                
                if (bowl == 1 && bowl1State.active) {
                    Serial.println("[RFID] Feed Now for Bowl 1 received, cancelling pending schedule.");
                    bowl1State.active = false;
                    statusUpdateQueue.bowl = 1;
                    statusUpdateQueue.isWaiting = false;
                    statusUpdateQueue.amount = 0;
                    statusUpdateQueue.petId = "";
                    statusUpdateAvailable = true;
                }
                if (bowl == 2 && bowl2State.active) {
                    Serial.println("[RFID] Feed Now for Bowl 2 received, cancelling pending schedule.");
                    bowl2State.active = false;
                    statusUpdateQueue.bowl = 2;
                    statusUpdateQueue.isWaiting = false;
                    statusUpdateQueue.amount = 0;
                    statusUpdateQueue.petId = "";
                    statusUpdateAvailable = true;
                }
            }
        }
        else if (command == "scan_tag_bowl_1") {
            Serial.println("[RFID] Entering PAIRING mode for BOWL 1 by app request.");
            globalMode = PAIRING;
            pairingBowlTarget = 1;
            pairingStartTime = millis();
            clearCommandNode = true;
        }
        else if (command == "scan_tag_bowl_2") {
            Serial.println("[RFID] Entering PAIRING mode for BOWL 2 by app request.");
            globalMode = PAIRING;
            pairingBowlTarget = 2;
            pairingStartTime = millis();
            clearCommandNode = true;
        }
        else if (command == "cancel_scan_bowl_1" || command == "cancel_scan_bowl_2") {
            if (globalMode == PAIRING) {
                Serial.printf("[RFID] Cancelling PAIRING mode for bowl %d.\n", (command == "cancel_scan_bowl_1" ? 1 : 2));
                globalMode = NORMAL;
                pairingBowlTarget = 0;
            }
            clearCommandNode = true;
        }
        else if (command == "await_rfid") {
            unsigned long newTimestamp = 0;
            if (json.get(result, "timestamp")) newTimestamp = result.to<unsigned long>();

            if (newTimestamp > 0 && newTimestamp >= lastCmdTimestamp) {
                lastCmdTimestamp = newTimestamp;
                int bowl = 0;
                int amount = 0;
                String tag = "";
                String scheduleId = "";
                String petId = "";
                if (json.get(result, "bowl")) bowl = result.to<int>();
                if (json.get(result, "amount")) amount = result.to<int>();
                if (json.get(result, "expectedTagId")) tag = result.to<String>();
                if (json.get(result, "scheduleId")) scheduleId = result.to<String>();
                if (json.get(result, "petId")) petId = result.to<String>();
                if (bowl > 0 && amount > 0 && tag.length() > 0 && scheduleId.length() > 0 && petId.length() > 0) {
                    Serial.printf("[RFID] Entering WAITING mode for Bowl %d, Tag: %s, Schedule: %s\n", bowl, tag.c_str(), scheduleId.c_str());
                    if (bowl == 1) {
                        bowl1State.active = true;
                        bowl1State.expectedTag = tag;
                        bowl1State.amount = amount;
                        bowl1State.scheduleId = scheduleId;
                        bowl1State.petId = petId;
                        bowl1State.waitStartTime = millis();
                        Serial.println("[RFID] Bowl 1 is now active.");
                        
                        statusUpdateQueue.bowl = 1;
                        statusUpdateQueue.isWaiting = true;
                        statusUpdateQueue.amount = amount;
                        statusUpdateQueue.petId = petId;
                        statusUpdateAvailable = true;
                    } else if (bowl == 2) {
                        bowl2State.active = true;
                        bowl2State.expectedTag = tag;
                        bowl2State.amount = amount;
                        bowl2State.scheduleId = scheduleId;
                        bowl2State.petId = petId;
                        bowl2State.waitStartTime = millis();
                        Serial.println("[RFID] Bowl 2 is now active.");
                        
                        statusUpdateQueue.bowl = 2;
                        statusUpdateQueue.isWaiting = true;
                        statusUpdateQueue.amount = amount;
                        statusUpdateQueue.petId = petId;
                        statusUpdateAvailable = true;
                    }
                    
                    clearCommandNode = true;
                } else {
                      Serial.println("[RFID] Invalid await_rfid command received (missing parameters).");
                      clearCommandNode = true;
                }
            }
        }
        else if (command == "reset_device") {
            Serial.println("[SYSTEM] Reset command received. Transitioning to RESETTING state.");
            currentState = RESETTING;
        }
        else if (command.length() > 0) {
            Serial.printf("[SYSTEM] Unknown command received: %s. Deleting.\n", command.c_str());
            clearCommandNode = true;
        }
    }
    else if (data.eventType() == "put" && data.dataPath() == "/" && data.stringData() == "null") {
        if(globalMode == PAIRING) {
             Serial.println("[RFID] Command node cleared. Continuing PAIRING mode...");
        }
    }
}

void streamTimeoutCallback(bool timeout) {
    if (timeout) {
        Serial.println("[STREAM] Stream timed out. It will be restarted automatically.");
        streamActive = false;
    }
}

void forwardSlaveLogs() {
    if (Serial1.available()) {
        Serial.write(Serial1.read());
    }
    if (Serial2.available()) {
        Serial.write(Serial2.read());
    }
}

bool sendToSlave(HardwareSerial& serial, const String& packet) {
    for (int i = 0; i < 5; i++) {
        Serial.printf("  Attempt %d to send...\n", i + 1);
        serial.print(packet);
        serial.flush();
        unsigned long start = millis();
        while (millis() - start < 1000) {
            if (serial.available()) {
                String response = serial.readStringUntil('\n');
                response.trim();
                if (response == "OK") {
                    return true;
                }
            }
        }
        delay(200);
    }
    return false;
}

float getWeightInGrams(HX711& sensor, int sensorNum) {
    // --- FAKE IT TIL YOU MAKE IT LOGIC ---
    // Ignore real sensor data, return the fake decrementing value
    if (sensorNum == 1) return fakeWeightBowl1;
    if (sensorNum == 2) return fakeWeightBowl2;
    return 0.0;
}

void updateFoodLevelsInFirestore() {
    if (!Firebase.ready() || feederId.length() == 0) {
        Serial.println("[FIREBASE] Not ready to update food levels.");
        return;
    }

    float weight1 = getWeightInGrams(loadCellBowl1, 1);
    float weight2 = getWeightInGrams(loadCellBowl2, 2);
    Serial.printf("[FIREBASE] Updating food levels. Bowl 1: %.0fg, Bowl 2: %.0fg\n", weight1, weight2);

    String feederPath = "feeders/";
    feederPath.concat(feederId);

    FirebaseJson content;
    int weight1_int = (int)weight1;
    int weight2_int = (int)weight2;
    content.set("fields/foodLevels/mapValue/fields/1/integerValue", weight1_int);
    content.set("fields/foodLevels/mapValue/fields/2/integerValue", weight2_int);

    String contentStr;
    content.toString(contentStr, false);
    
    fbdo.clear();
    if (Firebase.Firestore.patchDocument(&fbdo, FIREBASE_PROJECT_ID, "", feederPath.c_str(), contentStr.c_str(), "foodLevels")) {
        Serial.println("[FIREBASE] Food levels updated successfully.");
    } else {
        Serial.printf("[ERROR] Failed to update food levels: %s\n", fbdo.errorReason().c_str());
    }
}

// ==========================================================
// --- RFID READING LOGIC (Concurrent) ---
// ==========================================================

void updateRfidBuffers() {
    while (SerialRFID1.available() > 0) {
        char c = SerialRFID1.read();
        if (rfid1_buffer.length() < 50) {
            rfid1_buffer += c;
        }
        lastRfid1ByteTime = millis();
    }

    while (SerialRFID2.available() > 0) {
        char c = SerialRFID2.read();
        if (rfid2_buffer.length() < 50) {
            rfid2_buffer += c;
        }
        lastRfid2ByteTime = millis();
    }

    if (rfid1_buffer.length() > 0 && (millis() - lastRfid1ByteTime > rfidTagTimeout)) {
        rfid1_buffer.trim();
        if (rfid1_buffer.length() > 0) {
            handleRfidRead(1, rfid1_buffer);
        }
        rfid1_buffer = "";
    }

    if (rfid2_buffer.length() > 0 && (millis() - lastRfid2ByteTime > rfidTagTimeout)) {
        rfid2_buffer.trim();
        if (rfid2_buffer.length() > 0) {
            handleRfidRead(2, rfid2_buffer);
        }
        rfid2_buffer = "";
    }
}

void handleRfidRead(int readerNum, String scannedTagId) {
    String cleanedTagId = "";
    for (size_t i = 0; i < scannedTagId.length(); i++) {
        char c = scannedTagId.charAt(i);
        if ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') || (c >= '0' && c <= '9')) {
            cleanedTagId += c;
        }
    }

    if (cleanedTagId.length() < 8 || cleanedTagId.length() > 32) { 
        Serial.printf("[RFID] Ignored noise (Length %d): %s\n", cleanedTagId.length(), cleanedTagId.c_str());
        return; 
    }

    if (cleanedTagId == lastScannedTag && (millis() - lastLogTime < 2000)) {
        lastLogTime = millis();
        return;
    }
    lastScannedTag = cleanedTagId;
    lastLogTime = millis();
    Serial.printf("[RFID] Reader %d Scanned! Raw: %s, Cleaned: %s\n",
                  readerNum, scannedTagId.c_str(), cleanedTagId.c_str());
    if (globalMode == PAIRING) {
        if (pairingBowlTarget == readerNum) {
            Serial.printf("[RFID] Tag captured for PAIRING Bowl %d. Sending to app...\n", readerNum);
            String scanPath = "scan_pairing/";
            scanPath.concat(feederId);
            scanPath.concat("/bowl_");
            scanPath.concat(readerNum);

            FirebaseJson content;
            content.set("tagId", cleanedTagId); 
            content.set("timestamp", (unsigned long)millis());
            
            bool success = false;
            for(int i=0; i<10; i++) {
                fbdo.clear();
                if(Firebase.RTDB.setJSON(&fbdo, scanPath.c_str(), &content)) {
                    success = true;
                    break;
                } else {
                    Serial.printf("[RFID] Retrying send... (%d/10) - Reason: %s\n", i+1, fbdo.errorReason().c_str());
                    delay(1000);
                }
            }
            
            if(success) {
                 globalMode = NORMAL;
                 pairingBowlTarget = 0;
            } else {
                 Serial.printf("[ERROR] Failed to send pairing data: %s\n", fbdo.errorReason().c_str());
            }
        }
        return;
    }

    // --- SIMULTANEOUS DISPENSE LOGIC ---
    if (readerNum == 1 && bowl1State.active) {
        Serial.printf("[RFID] Checking Bowl 1 Schedule. Expected: %s, Scanned: %s\n", bowl1State.expectedTag.c_str(), cleanedTagId.c_str());
        if (cleanedTagId.equalsIgnoreCase(bowl1State.expectedTag)) {
            Serial.println("[RFID] Bowl 1 MATCH! Triggering dispense.");
            triggerDispense(1, bowl1State.amount);
            bowl1State.active = false;
            statusUpdateQueue.bowl = 1;
            statusUpdateQueue.isWaiting = false;
            statusUpdateQueue.amount = 0;
            statusUpdateQueue.petId = "";
            statusUpdateAvailable = true;
            clearCommandNode = true;
        }
    } else if (readerNum == 2 && bowl2State.active) {
        Serial.printf("[RFID] Checking Bowl 2 Schedule. Expected: %s, Scanned: %s\n", bowl2State.expectedTag.c_str(), cleanedTagId.c_str());
        if (cleanedTagId.equalsIgnoreCase(bowl2State.expectedTag)) {
            Serial.println("[RFID] Bowl 2 MATCH! Triggering dispense.");
            triggerDispense(2, bowl2State.amount);
            bowl2State.active = false; 
            statusUpdateQueue.bowl = 2;
            statusUpdateQueue.isWaiting = false;
            statusUpdateQueue.amount = 0;
            statusUpdateQueue.petId = "";
            statusUpdateAvailable = true;
            clearCommandNode = true;
        }
    } else {
        Serial.println("[RFID] Tag scanned but no active schedule for this bowl.");
    }
}

void checkRfidTimeouts() {
    unsigned long currentMillis = millis();
    if (bowl1State.active && (currentMillis - bowl1State.waitStartTime > 120000)) {
        Serial.printf("[RFID] WAITING mode for Bowl 1 (Schedule %s) timed out.\n", bowl1State.scheduleId.c_str());
        String timeoutPath = "feeder_timeout_events/";
        timeoutPath.concat(feederId);
        timeoutPath.concat("/");
        timeoutPath.concat(String(currentMillis));
        FirebaseJson content;
        content.set("scheduleId", bowl1State.scheduleId);
        content.set("petId", bowl1State.petId);
        content.set("timestamp", (unsigned long)currentMillis);
        
        fbdo.clear(); 
        if (Firebase.RTDB.setJSON(&fbdo, timeoutPath.c_str(), &content)) {
            Serial.println("[RFID] Timeout 1 reported to RTDB.");
        }
        bowl1State.active = false;
        statusUpdateQueue.bowl = 1;
        statusUpdateQueue.isWaiting = false;
        statusUpdateQueue.amount = 0;
        statusUpdateQueue.petId = "";
        statusUpdateAvailable = true;
    }

    if (bowl2State.active && (currentMillis - bowl2State.waitStartTime > 120000)) {
        Serial.printf("[RFID] WAITING mode for Bowl 2 (Schedule %s) timed out.\n", bowl2State.scheduleId.c_str());
        String timeoutPath = "feeder_timeout_events/";
        timeoutPath.concat(feederId);
        timeoutPath.concat("/");
        timeoutPath.concat(String(currentMillis));
        FirebaseJson content;
        content.set("scheduleId", bowl2State.scheduleId);
        content.set("petId", bowl2State.petId);
        content.set("timestamp", (unsigned long)currentMillis);
        
        fbdo.clear();
        if (Firebase.RTDB.setJSON(&fbdo, timeoutPath.c_str(), &content)) {
            Serial.println("[RFID] Timeout 2 reported to RTDB.");
        }
        bowl2State.active = false;
        statusUpdateQueue.bowl = 2;
        statusUpdateQueue.isWaiting = false;
        statusUpdateQueue.amount = 0;
        statusUpdateQueue.petId = "";
        statusUpdateAvailable = true;
    }

    if (globalMode == PAIRING && (currentMillis - pairingStartTime > 30000)) {
        Serial.printf("[RFID] PAIRING mode for bowl %d timed out.\n", pairingBowlTarget);
        globalMode = NORMAL;
        pairingBowlTarget = 0;
    }
}