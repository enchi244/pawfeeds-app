#include <Arduino.h>
#include <WiFi.h>
#include <Preferences.h>
#include <Firebase_ESP_Client.h>
#include <ESP32Servo.h>
#include <time.h>
#include <HX711.h>

// ========== USER CONFIGURATION ==========
#define FIREBASE_PROJECT_ID "pawfeeds-v2"
#define FIREBASE_DATABASE_URL "https://pawfeeds-v2-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define SERVICE_ACCOUNT_CLIENT_EMAIL "firebase-adminsdk-fbsvc@pawfeeds-v2.iam.gserviceaccount.com"
#define SERVICE_ACCOUNT_PRIVATE_KEY "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC+Sqt8BKfCEgbp\n/q4XmzzpsKwlsKJesbWN/Sp2PO7nVgPqwEz9YeCy/aI98IjyGY5hujaLLNgB0GYE\nNLvWkAf3T6VQPUa8SB28XU5sT7tfCJu/1F3yYYAVHHpbg2gbGxjgPWVlQ5arww57\nHHREzOUTRTO5k9hRAzzf1kdjBJbboewEEcIQH2uAdn+B9L58SOezjVONpr63+R5V\nWbZ7+B64BFE62Xsjcmk49OmHjKc+2ID80S6EWx6rxM5jGdTsUVtA0RISG5r1qeB/\nDazLCx1jexutuMHTogvAIirHGIMdOCW12USD8b+CRvP7Lsj6CwR91JSVm/b5P1pI\n0MNAgkfrAgMBAAECggEAO5iNHlki5P/aVHxjr5b5u8KOF3u7TmbfkmmAW+l3dNIW\nhfXV5uE5izUuE7H6YcApPGgiXvIbcG4BFT4iue7/3698+aVHOv5m+bBLOFa8OuYq\nSSjMh3WLtJDnrTN5bkvNPaVc1RsW3BJJvbrKmyWEdMWOjodEDxMxhHTKhLNSP9Rq\ncTz85kc4/IsXuAD6fmApysrWiVuS+vcIzFGCjqQDozojsd58KW6XFa8PEZ95bUbE\n/Q8ZAigB88un8+87NpLd/usUk2FWHNJz523AJUA4qQE0N8J6E/7+dJbRJ9Ucg6lk\nkO0fRiLO7c7o6/7bW1iy4Yq+ph5N3+vc2pYzVZIkAQKBgQD0AbH86UoJxroGh/id\n849814dnEGugSQ1C2XCPNpQy19WtyfZvMM5yphfxfxxohJwr+KyQBcfBatGo/ipV\n9cIJUOalKa+q9KzxLsSka41cvu4RsnVjWyVqGS4w/BdYFdTvNkuK3cGiK8qYwBaW\ni50PNrcCQ+7gmMCjkPJ6LDOh6wKBgQDHpRYRXk9ipsOw4KHBxn4rph8G6ooUIvzs\nPie0e+A+pz9grNDC7y0a+k8fA4eq/iJPmu+FvuJW4fahCkt98VuW0EJjcqtBNgCB\nYbOKn9H+V4WaQKCHYyhl/QxGio4qm4z34cEVt/kMGwGHlaX39RILc3kEq2RfTSc7\n2FikgZxyAQKBgQCz61wWpN5W/xXEIxaLQUCYSUQqFs2FTthcZoC82P3Fz6hbkQQJ\nUO+pUhdtltCXsNCHC8ISIHD+iYk3FtKYt7HvtJudRXOmluu+m0GcC0IdFRvuKKyu\nKlMYPKD2tatw5AgyqtJg/sr8jVXB9EGzmBajVTD0lqrZKUlCUmq480bPKQKBgQCp\nTo0qaYp1JOur4rQK+uQg7B4/5UL31LwdNJDDdJI1T+xldekMh3z+9euHZ5z0G9TJ\nIaGjEMAt4i8fXvWqdravbSn/4EzvXnaLQmnaU7LoORzqNYhtiF/ILhLs96+c3pFr\n3h2652vjIjvn2bcIUuLcpy6oERlr4Kg3DkAOMoSUAQKBgQCkTg6e4Ndg1d2SySFQ\n4h7YHQZ3larxK/03DFoElNIf/6zgiNL13+9nM3l4K8YAEG1OEcn5JaBdktmGrEWR\nA+zV7Qp/hZSVuOM4sxpGa7q94A5253tvLvegIvzhFYW4WQrVFadI5xZ1HaO2Ad9I\nKzz19+jbd085r+kyTM5X0UVzZA==\n-----END PRIVATE KEY-----\n"

#define SERVO_BOWL_1_PIN 21
#define SERVO_BOWL_2_PIN 22

// --- MODIFIED: Bowl 1 Weight Sensor Pins ---
#define HX711_BOWL1_DOUT_PIN 27
#define HX711_BOWL1_SCK_PIN 26

// --- NEW: Bowl 2 Weight Sensor Pins ---
// (Please change these pins if you use 19 or 18 for something else)
#define HX711_BOWL2_DOUT_PIN 19
#define HX711_BOWL2_SCK_PIN 18

#define SLAVE_1_SERIAL_TX_PIN 13
#define SLAVE_1_SERIAL_RX_PIN 12
#define SLAVE_2_SERIAL_TX_PIN 15
#define SLAVE_2_SERIAL_RX_PIN 14
#define DISPENSE_MS_PER_GRAM 50
const char* AP_SSID = "PawFeeds_Setup";
const char* AP_PASSWORD = NULL;

// --- MODIFIED: Weight Sensor Configuration ---
// (You MUST calibrate both sensors)
#define CALIBRATION_FACTOR_1 -7050.0 
#define CALIBRATION_FACTOR_2 -7050.0 
// --- NEW: Define max container weight in grams for percentage calculation
#define MAX_WEIGHT_GRAMS 2000.0 // e.g., 2kg container

// --- Global Objects & State Machine ---
WiFiServer server(80);
Preferences preferences;
FirebaseData stream_fbdo;
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;
Servo servoBowl1;
Servo servoBowl2;

// --- MODIFIED: Create two load cell objects ---
HX711 loadCellBowl1;
HX711 loadCellBowl2;

String feederId = "";
String streamPath = "/commands/";
bool streamActive = false;
unsigned long lastCmdTimestamp = 0;

// --- NEW: Timer for periodic weight updates ---
unsigned long lastWeightUpdateTime = 0; 

volatile bool newCommandAvailable = false;
struct Command {
    int bowl;
    int amount;
};
Command pendingCommand;
enum DeviceState {
    PROVISIONING_MODE,
    CONNECTING_WIFI,
    SYNCING_TIME,
    AUTHENTICATING_FIREBASE,
    REGISTERING_FIREBASE,
    OPERATIONAL,
    ERROR
};
DeviceState currentState = PROVISIONING_MODE;

// --- Function Prototypes ---
void tokenStatusCallback(TokenInfo info);
void connectToWiFi();
void syncTime();
void authenticateWithFirebase();
void registerDeviceWithFirestore();
void startProvisioningServer();
void handleClient();
String urlDecode(String str);
String parseFeederIdFromResponse(String response);
void dispenseFood(int bowl, int amount);
void processPendingCommand();
void startRTDBStream();
void streamCallback(FirebaseStream data);
void streamTimeoutCallback(bool timeout);
void forwardSlaveLogs();
bool sendToSlave(HardwareSerial& serial, const String& packet);
void forwardPacketToSlaves(const String& packet, const String& packetType);

// --- MODIFIED: New/Removed Function Prototypes ---
void updateFoodLevelsInFirestore();
float getWeightAsPercentage(HX711& sensor, int sensorNum);
// void updateContainerWeightInFirestore(float weight); // <-- REMOVED
// float getContainerWeight(); // <-- REMOVED
// void checkFoodLevelAndNotify(float currentWeight); // <-- REMOVED

void forwardPacketToSlaves(const String& packet, const String& packetType) {
    Serial.printf("[PROVISIONING] Forwarding %s to slave cameras...\n", packetType.c_str());
    Serial.println("[PROVISIONING] Contacting Slave 1...");
    Serial2.begin(9600, SERIAL_8N1, SLAVE_1_SERIAL_RX_PIN, SLAVE_1_SERIAL_TX_PIN);
    if (sendToSlave(Serial2, packet)) {
        Serial.printf("[PROVISIONING] %s sent to Slave 1 successfully.\n", packetType.c_str());
    } else {
        Serial.printf("[ERROR] Failed to send %s to Slave 1.\n", packetType.c_str());
    }
    Serial2.end();
    delay(500);

    Serial.println("[PROVISIONING] Contacting Slave 2...");
    Serial1.begin(9600, SERIAL_8N1, SLAVE_2_SERIAL_RX_PIN, SLAVE_2_SERIAL_TX_PIN);
    if (sendToSlave(Serial1, packet)) {
        Serial.printf("[PROVISIONING] %s sent to Slave 2 successfully.\n", packetType.c_str());
    } else {
        Serial.printf("[ERROR] Failed to send %s to Slave 2.\n", packetType.c_str());
    }
    Serial1.end();
    Serial.println("[PROVISIONING] Forwarding complete.");
}

void setup() {
    Serial.begin(115200);
    Serial.println("\n[PawFeeds] Booting...");
    servoBowl1.attach(SERVO_BOWL_1_PIN);
    servoBowl2.attach(SERVO_BOWL_2_PIN);

    // --- MODIFIED: Initialize both weight sensors ---
    Serial.println("[HX711] Initializing weight sensor 1...");
    loadCellBowl1.begin(HX711_BOWL1_DOUT_PIN, HX711_BOWL1_SCK_PIN);
    loadCellBowl1.set_scale(CALIBRATION_FACTOR_1);
    loadCellBowl1.tare();
    
    Serial.println("[HX711] Initializing weight sensor 2...");
    loadCellBowl2.begin(HX711_BOWL2_DOUT_PIN, HX711_BOWL2_SCK_PIN);
    loadCellBowl2.set_scale(CALIBRATION_FACTOR_2);
    loadCellBowl2.tare();
    
    Serial.println("[HX711] Ready. Please fill food containers now.");
    delay(5000);

    preferences.begin("pawfeeds", false);
    if (preferences.getString("ssid", "").length() > 0) {
        currentState = CONNECTING_WIFI;
    } else {
        currentState = PROVISIONING_MODE;
        startProvisioningServer();
    }
}

void loop() {
    forwardSlaveLogs();
    switch (currentState) {
        case PROVISIONING_MODE:
            handleClient();
            break;
        case CONNECTING_WIFI:
            connectToWiFi();
            break;
        case SYNCING_TIME:
            syncTime();
            break;
        case AUTHENTICATING_FIREBASE:
            authenticateWithFirebase();
            break;
        case REGISTERING_FIREBASE:
            registerDeviceWithFirestore();
            break;
        case OPERATIONAL:
            if (!streamActive) {
                startRTDBStream();
            }
            if (Firebase.ready() && !Firebase.RTDB.readStream(&stream_fbdo)) {
                Serial.println("[ERROR] Stream read error!");
                streamActive = false;
            }
            if (newCommandAvailable) {
                processPendingCommand();
                newCommandAvailable = false;
            }

            // --- NEW: Periodically update weight every 5 minutes ---
            if (millis() - lastWeightUpdateTime > 300000) { // 300,000 ms = 5 mins
                Serial.println("[SYSTEM] Time to update weight levels...");
                updateFoodLevelsInFirestore();
                lastWeightUpdateTime = millis(); // Reset the timer
            }
            // --- END OF NEW BLOCK ---

            break;
        case ERROR:
            Serial.println("[ERROR] Halting.");
            delay(10000);
            break;
    }
    delay(100);
}

void tokenStatusCallback(TokenInfo info) {
    if (info.status == token_status_ready) {
        Serial.println("[AUTH] Token obtained successfully.");
    } else if (info.status == token_status_error) {
        Serial.printf("[AUTH] Token error: %s\n", info.error.message.c_str());
        currentState = ERROR;
    }
}

void connectToWiFi() {
    Serial.println("[WIFI] Connecting...");
    WiFi.begin(preferences.getString("ssid").c_str(), preferences.getString("pass").c_str());
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 30) {
        delay(500);
        Serial.print(".");
        attempts++;
    }

    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\n[WIFI] Connected!");
        currentState = SYNCING_TIME;
    } else {
        Serial.println("\n[WIFI] Failed!");
        currentState = ERROR;
    }
}

void syncTime() {
    Serial.println("[TIME] Syncing with NTP server...");
    configTime(8 * 3600, 0, "pool.ntp.org", "time.nist.gov");
    
    time_t now = time(nullptr);
    int attempts = 0;
    while (now < 8 * 3600 * 2 && attempts < 30) {
        delay(500);
        now = time(nullptr);
        attempts++;
    }

    if (now < 8 * 3600 * 2) {
        Serial.println("[TIME] Failed to sync time!");
        currentState = ERROR;
    } else {
        struct tm timeinfo;
        gmtime_r(&now, &timeinfo);
        Serial.print("[TIME] Time synced successfully: ");
        Serial.print(asctime(&timeinfo));
        currentState = AUTHENTICATING_FIREBASE;
    }
}

void authenticateWithFirebase() {
    if(Firebase.ready()) {
        Serial.println("[AUTH] Already authenticated.");
        feederId = preferences.getString("feederId", "");
        if(feederId.length() > 0) {
            currentState = OPERATIONAL;
        } else {
            currentState = REGISTERING_FIREBASE;
        }
        return;
    }
    
    Serial.println("[AUTH] Configuring service account...");
    config.database_url = FIREBASE_DATABASE_URL;
    config.service_account.data.client_email = SERVICE_ACCOUNT_CLIENT_EMAIL;
    config.service_account.data.project_id = FIREBASE_PROJECT_ID;
    config.service_account.data.private_key = SERVICE_ACCOUNT_PRIVATE_KEY;
    config.token_status_callback = tokenStatusCallback;

    Firebase.begin(&config, &auth);
    Firebase.reconnectWiFi(true);
}


// ==========================================================
// === FUNCTION 1: REPLACED WITH FIXED VERSION            ===
// ==========================================================
void registerDeviceWithFirestore() {
    if (!Firebase.ready()) {
        Serial.println("[FIREBASE] Waiting for auth token...");
        return;
    }

    Serial.println("[FIREBASE] Registering device...");
    String owner_uid = preferences.getString("owner_uid", "");
    if (owner_uid.length() == 0) {
        currentState = ERROR;
        return;
    }

    FirebaseJson content;
    content.set("fields/owner_uid/stringValue", owner_uid);
    content.set("fields/online/booleanValue", true); 

    // --- MODIFIED: Set initial food levels from both sensors ---
    float initialPercent1 = getWeightAsPercentage(loadCellBowl1, 1);
    float initialPercent2 = getWeightAsPercentage(loadCellBowl2, 2);

    // ==========================================================
    // === FIX: Cast floats to int before setting             ===
    // ==========================================================
    int initialPercent1_int = (int)initialPercent1;
    int initialPercent2_int = (int)initialPercent2;
    content.set("fields/foodLevels/mapValue/fields/1/integerValue", initialPercent1_int);
    content.set("fields/foodLevels/mapValue/fields/2/integerValue", initialPercent2_int);
    
    String feederContent;
    content.toString(feederContent, false);

    if (Firebase.Firestore.createDocument(&fbdo, FIREBASE_PROJECT_ID, "", "feeders", feederContent.c_str())) {
        Serial.println("[FIREBASE] Feeder document created.");
        feederId = parseFeederIdFromResponse(fbdo.payload());
        if (feederId.length() > 0) {
            preferences.putString("feederId", feederId);
            String feederIdPacket = "FEEDER_ID|";
            feederIdPacket.concat(feederId);
            feederIdPacket.concat("\n");
            forwardPacketToSlaves(feederIdPacket, "Feeder ID");

            String usersPath = "users/";
            usersPath.concat(owner_uid);
            
            FirebaseJson userUpdateContent;
            userUpdateContent.set("fields/feederId/stringValue", feederId);
            String userContent;
            userUpdateContent.toString(userContent, false);
            if (Firebase.Firestore.patchDocument(&fbdo, FIREBASE_PROJECT_ID, "", usersPath.c_str(), userContent.c_str(), "feederId")) {
                Serial.println("[FIREBASE] User patched. Setup complete!");
                currentState = OPERATIONAL;
            } else {
                Serial.printf("[ERROR] Failed to patch user: %s\n", fbdo.errorReason().c_str());
                currentState = ERROR;
            }
        } else {
            Serial.println("[ERROR] Failed to parse feeder ID from response.");
            currentState = ERROR;
        }
    } else {
        Serial.printf("[ERROR] Failed to create feeder doc: %s\n", fbdo.errorReason().c_str());
        currentState = ERROR;
    }
}


void startProvisioningServer() {
    Serial.print("[PROVISIONING] Starting Access Point: ");
    Serial.println(AP_SSID);
    WiFi.softAP(AP_SSID, AP_PASSWORD);
    IPAddress IP = WiFi.softAPIP();
    Serial.print("[PROVISIONING] AP IP address: ");
    Serial.println(IP.toString());
    server.begin();
    Serial.println("[PROVISIONING] Web server started.");
}

void handleClient() {
    WiFiClient client = server.available();
    if (!client) return;
    String currentLine = "";
    unsigned long timeout = millis();
    String header = "";
    while (client.connected() && millis() - timeout < 2000) {
        if (client.available()) {
            char c = client.read();
            header += c;
            if (c == '\n') {
                if (currentLine.length() == 0) {
                    if (header.indexOf("GET /networks") >= 0) {
                        int n = WiFi.scanNetworks();
                        String json = "[";
                        for (int i = 0; i < n; ++i) {
                            if (i > 0) json.concat(",");
                            json.concat("{\"ssid\":\"");
                            json.concat(WiFi.SSID(i));
                            json.concat("\",\"rssi\":");
                            json.concat(WiFi.RSSI(i));
                            json.concat("}");
                        }
                        json += "]";
                        client.println("HTTP/1.1 200 OK");
                        client.println("Content-type:application/json");
                        client.println("Connection: close");
                        client.println();
                        client.println(json);
                    } else if (header.indexOf("POST /save") >= 0) {
                        String body;
                        while (client.available()) { body += (char)client.read(); }
                        int ssid_start = body.indexOf("ssid=") + 5;
                        int ssid_end = body.indexOf("&", ssid_start);
                        String ssid = urlDecode(body.substring(ssid_start, ssid_end));
                        int pass_start = body.indexOf("pass=") + 5;
                        int pass_end = body.indexOf("&", pass_start);
                        String pass = urlDecode(body.substring(pass_start, pass_end));
                        int uid_start = body.indexOf("uid=") + 4;
                        String uid = urlDecode(body.substring(uid_start));
                        preferences.putString("ssid", ssid);
                        preferences.putString("pass", pass);
                        preferences.putString("owner_uid", uid);
                        
                        String credentialsPacket = ssid;
                        credentialsPacket.concat("|");
                        credentialsPacket.concat(pass);
                        credentialsPacket.concat("\n");
                        forwardPacketToSlaves(credentialsPacket, "Credentials");

                        client.println("HTTP/1.1 200 OK\r\nContent-type:text/html\r\n\r\n<h1>Saved! Restarting...</h1>");
                        delay(1500);
                    }
                    break;
                } else {
                    currentLine = "";
                }
            } else if (c != '\r') {
                currentLine += c;
            }
        }
    }
    client.stop();
    if (header.indexOf("POST /save") >= 0) {
        Serial.println("[PROVISIONING] Credentials saved. Restarting device.");
        ESP.restart();
    }
}

String parseFeederIdFromResponse(String response) {
    FirebaseJson json;
    json.setJsonData(response);
    FirebaseJsonData result;
    if (json.get(result, "name")) {
        String path = result.to<String>();
        int lastSlash = path.lastIndexOf('/');
        if (lastSlash != -1) {
            return path.substring(lastSlash + 1);
        }
    }
    return "";
}

String urlDecode(String str) {
    String decodedString = "";
    char temp[] = "0x00";
    char c;
    for (size_t i = 0; i < str.length(); i++) {
        c = str.charAt(i);
        if (c == '+') {
            decodedString += ' ';
        } else if (c == '%') {
            i++;
            temp[2] = str.charAt(i);
            i++;
            temp[3] = str.charAt(i);
            decodedString += (char)strtol(temp, NULL, 16);
        } else {
            decodedString += c;
        }
    }
    return decodedString;
}

void processPendingCommand() {
    if (pendingCommand.amount > 0 && pendingCommand.bowl > 0) {
        Serial.printf("[COMMAND] Processing command! Bowl: %d, Amount: %d\n", pendingCommand.bowl, pendingCommand.amount);
        dispenseFood(pendingCommand.bowl, pendingCommand.amount);

        String fullStreamPath = streamPath;
        fullStreamPath.concat(feederId);
        if (Firebase.RTDB.deleteNode(&fbdo, fullStreamPath.c_str())) {
            Serial.println("[COMMAND] Command node deleted successfully.");
        } else {
            Serial.printf("[COMMAND] FAILED to delete command node: %s\n", fbdo.errorReason().c_str());
        }
    }
}

void dispenseFood(int bowlNumber, int amount) {
    Serial.printf("[SERVO] Dispensing %d grams from bowl %d.\n", amount, bowlNumber);
    Servo* targetServo = nullptr;
    if (bowlNumber == 1) targetServo = &servoBowl1;
    else if (bowlNumber == 2) targetServo = &servoBowl2;
    if (targetServo != nullptr) {
        long dispenseDuration = amount * DISPENSE_MS_PER_GRAM;
        Serial.printf("[SERVO] Rotating for %ld ms.\n", dispenseDuration);

        targetServo->write(0);
        delay(dispenseDuration);
        targetServo->write(90);
        
        delay(2000);
        
        // --- MODIFIED: Update all food levels after dispensing ---
        // This will read both sensors and update the foodLevels map in Firestore.
        // The cloud function will then detect the change and send a notification if needed.
        updateFoodLevelsInFirestore();

        // --- REMOVED: Old single-weight update logic ---
        // float newWeight = getContainerWeight();
        // updateContainerWeightInFirestore(newWeight);
        // checkFoodLevelAndNotify(newWeight);
    }
}

void startRTDBStream() {
    if (feederId.length() == 0 || !Firebase.ready()) return;
    String fullStreamPath = streamPath;
    fullStreamPath.concat(feederId);
    Serial.print("[STREAM] Starting stream on path: ");
    Serial.println(fullStreamPath);
    if (!Firebase.RTDB.beginStream(&stream_fbdo, fullStreamPath.c_str())) {
        Serial.printf("[STREAM] Could not begin stream: %s\n", stream_fbdo.errorReason().c_str());
        return;
    }
    Firebase.RTDB.setStreamCallback(&stream_fbdo, streamCallback, streamTimeoutCallback);
    streamActive = true;
    Serial.println("[STREAM] Stream started successfully.");
}

void streamCallback(FirebaseStream data) {
    Serial.printf("[STREAM] Event: %s, Path: %s, Data: %s\n", data.eventType().c_str(), data.dataPath().c_str(), data.payload().c_str());
    if (data.dataType() == "json" && data.dataPath() == "/") {
        FirebaseJson json;
        json.setJsonData(data.payload());
        FirebaseJsonData result;

        if (json.get(result, "scheduled_feed")) {
            if (result.typeNum == FirebaseJson::JSON_OBJECT) {
                FirebaseJson schedule_json;
                schedule_json.setJsonData(result.to<String>());
                
                int bowl = 0;
                int amount = 0;
                if (schedule_json.get(result, "bowl")) bowl = result.to<int>();
                if (schedule_json.get(result, "amount")) amount = result.to<int>();

                pendingCommand = {bowl, amount};
                newCommandAvailable = true;
                return;
            }
        }

        String command;
        if (json.get(result, "command")) {
            command = result.to<String>();
        }

        if (command == "feed") {
            unsigned long newTimestamp = 0;
            int bowl = 0;
            int amount = 0;
            if (json.get(result, "timestamp")) newTimestamp = result.to<unsigned long>();
            if (json.get(result, "bowl")) bowl = result.to<int>();
            if (json.get(result, "amount")) amount = result.to<int>();
            if (newTimestamp > 0 && newTimestamp > lastCmdTimestamp) {
                lastCmdTimestamp = newTimestamp;
                pendingCommand = {bowl, amount};
                newCommandAvailable = true;
            }
        } else if (command == "reset_device") {
            Serial.println("[SYSTEM] Reset command received. Clearing credentials and restarting.");
            preferences.clear();
            ESP.restart();
        }
    }
}

void streamTimeoutCallback(bool timeout) {
    if (timeout) {
        Serial.println("[STREAM] Stream timed out. It will be restarted automatically.");
        streamActive = false;
    }
}

void forwardSlaveLogs() {
    if (Serial1.available()) {
        Serial.write(Serial1.read());
    }
    if (Serial2.available()) {
        Serial.write(Serial2.read());
    }
}

bool sendToSlave(HardwareSerial& serial, const String& packet) {
    for (int i = 0; i < 5; i++) {
        Serial.printf("  Attempt %d to send...\n", i + 1);
        serial.print(packet);
        serial.flush(); 
        unsigned long start = millis();
        while (millis() - start < 1000) { 
            if (serial.available()) {
                String response = serial.readStringUntil('\n');
                response.trim();
                if (response == "OK") {
                    return true;
                }
            }
        }
        delay(200);
    }
    return false;
}


// --- REMOVED OLD WEIGHT FUNCTIONS ---
/*
float getContainerWeight() {
    if (loadCellContainer.is_ready()) {
        return loadCellContainer.get_units(10);
    } else {
        Serial.println("[HX711] Container sensor not found.");
        return 0;
    }
}
void updateContainerWeightInFirestore(float weight) {
    ...
}
void checkFoodLevelAndNotify(float currentWeight) {
    ...
}
*/

// --- NEW: Weight Reading Function (Converts Grams to Percentage) ---
float getWeightAsPercentage(HX711& sensor, int sensorNum) {
    if (sensor.is_ready()) {
        float weightGrams = sensor.get_units(10);
        
        // Ensure weight isn't negative (e.g., from calibration drift)
        if (weightGrams < 0) weightGrams = 0;
        
        // Convert to percentage
        float percentage = (weightGrams / MAX_WEIGHT_GRAMS) * 100.0;
        
        // Clamp percentage between 0 and 100
        if (percentage < 0) return 0;
        if (percentage > 100) return 100;
        return percentage;
    } else {
        Serial.printf("[HX711] Sensor %d not found.\n", sensorNum);
        return 0; // Return 0% if sensor is disconnected
    }
}


// ==========================================================
// === FUNCTION 2: REPLACED WITH FIXED VERSION            ===
// ==========================================================
void updateFoodLevelsInFirestore() {
    if (!Firebase.ready() || feederId.length() == 0) {
        Serial.println("[FIREBASE] Not ready to update food levels.");
        return;
    }

    // Read percentages from both sensors
    float percent1 = getWeightAsPercentage(loadCellBowl1, 1);
    float percent2 = getWeightAsPercentage(loadCellBowl2, 2);

    Serial.printf("[FIREBASE] Updating food levels. Bowl 1: %.0f%%, Bowl 2: %.0f%%\n", percent1, percent2);

    String feederPath = "feeders/";
    feederPath.concat(feederId);

    // This JSON structure MUST match the cloud function (index.ts)
    // { "fields": { "foodLevels": { "mapValue": { "fields": { "1": { "integerValue": ... }, "2": { ... } } } } }
    FirebaseJson content;
    
    // ==========================================================
    // === FIX: Cast floats to int before setting             ===
    // ==========================================================
    int percent1_int = (int)percent1;
    int percent2_int = (int)percent2;
    content.set("fields/foodLevels/mapValue/fields/1/integerValue", percent1_int); 
    content.set("fields/foodLevels/mapValue/fields/2/integerValue", percent2_int);
    
    String contentStr;
    content.toString(contentStr, false);

    // We are patching ONLY the "foodLevels" field in the document
    if (Firebase.Firestore.patchDocument(&fbdo, FIREBASE_PROJECT_ID, "", feederPath.c_str(), contentStr.c_str(), "foodLevels")) {
        Serial.println("[FIREBASE] Food levels updated successfully.");
    } else {
        Serial.printf("[ERROR] Failed to update food levels: %s\n", fbdo.errorReason().c_str());
    }
}