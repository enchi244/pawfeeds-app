/**
 * PawFeeds Camera Firmware - High FPS Optimization
 * STATUS: Working / Tuned for Speed
 * * OPTIMIZATIONS:
 * 1. Resolution dropped to CIF (400x296) for speed.
 * 2. JPEG Quality relaxed to 16 (smaller packets).
 * 3. Triple buffering enabled (fb_count = 3).
 * 4. Removed artificial delay(100) limiter.
 */

#include "esp_camera.h"
#include "Arduino.h"
#include "FS.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "driver/rtc_io.h"
#include <WiFi.h>
#include <Preferences.h>
#include "esp_http_server.h"
#include <Firebase_ESP_Client.h>
#include <time.h> 
#include <ESPmDNS.h> 
#include "lwip/dns.h"
#include "lwip/ip_addr.h"

// --- FIX: REMOVED TokenHelper.h to prevent redefinition error ---
#include "addons/RTDBHelper.h"

// ==========================================================
// CONFIGURATION
// ==========================================================
#define BOWL_NUMBER 1 // 1 or 2
// ==========================================================

// --- FIREBASE CONFIGURATION ---
#define FIREBASE_PROJECT_ID "pawfeeds-v2"
#define FIREBASE_DATABASE_URL "https://pawfeeds-v2-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define SERVICE_ACCOUNT_CLIENT_EMAIL "firebase-adminsdk-fbsvc@pawfeeds-v2.iam.gserviceaccount.com"

#define SERVICE_ACCOUNT_PRIVATE_KEY "-----BEGIN PRIVATE KEY-----\n" \
"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC+Sqt8BKfCEgbp\n" \
"/q4XmzzpsKwlsKJesbWN/Sp2PO7nVgPqwEz9YeCy/aI98IjyGY5hujaLLNgB0GYE\n" \
"NLvWkAf3T6VQPUa8SB28XU5sT7tfCJu/1F3yYYAVHHpbg2gbGxjgPWVlQ5arww57\n" \
"HHREzOUTRTO5k9hRAzzf1kdjBJbboewEEcIQH2uAdn+B9L58SOezjVONpr63+R5V\n" \
"WbZ7+B64BFE62Xsjcmk49OmHjKc+2ID80S6EWx6rxM5jGdTsUVtA0RISG5r1qeB/\n" \
"DazLCx1jexutuMHTogvAIirHGIMdOCW12USD8b+CRvP7Lsj6CwR91JSVm/b5P1pI\n" \
"0MNAgkfrAgMBAAECggEAO5iNHlki5P/aVHxjr5b5u8KOF3u7TmbfkmmAW+l3dNIW\n" \
"hfXV5uE5izUuE7H6YcApPGgiXvIbcG4BFT4iue7/3698+aVHOv5m+bBLOFa8OuYq\n" \
"SSjMh3WLtJDnrTN5bkvNPaVc1RsW3BJJvbrKmyWEdMWOjodEDxMxhHTKhLNSP9Rq\n" \
"cTz85kc4/IsXuAD6fmApysrWiVuS+vcIzFGCjqQDozojsd58KW6XFa8PEZ95bUbE\n" \
"/Q8ZAigB88un8+87NpLd/usUk2FWHNJz523AJUA4qQE0N8J6E/7+dJbRJ9Ucg6lk\n" \
"kO0fRiLO7c7o6/7bW1iy4Yq+ph5N3+vc2pYzVZIkAQKBgQD0AbH86UoJxroGh/id\n" \
"849814dnEGugSQ1C2XCPNpQy19WtyfZvMM5yphfxfxxohJwr+KyQBcfBatGo/ipV\n" \
"9cIJUOalKa+q9KzxLsSka41cvu4RsnVjWyVqGS4w/BdYFdTvNkuK3cGiK8qYwBaW\n" \
"i50PNrcCQ+7gmMCjkPJ6LDOh6wKBgQDHpRYRXk9ipsOw4KHBxn4rph8G6ooUIvzs\n" \
"Pie0e+A+pz9grNDC7y0a+k8fA4eq/iJPmu+FvuJW4fahCkt98VuW0EJjcqtBNgCB\n" \
"YbOKn9H+V4WaQKCHYyhl/QxGio4qm4z34cEVt/kMGwGHlaX39RILc3kEq2RfTSc7\n" \
"2FikgZxyAQKBgQCz61wWpN5W/xXEIxaLQUCYSUQqFs2FTthcZoC82P3Fz6hbkQQJ\n" \
"UO+pUhdtltCXsNCHC8ISIHD+iYk3FtKYt7HvtJudRXOmluu+m0GcC0IdFRvuKKyu\n" \
"KlMYPKD2tatw5AgyqtJg/sr8jVXB9EGzmBajVTD0lqrZKUlCUmq480bPKQKBgQCp\n" \
"To0qaYp1JOur4rQK+uQg7B4/5UL31LwdNJDDdJI1T+xldekMh3z+9euHZ5z0G9TJ\n" \
"IaGjEMAt4i8fXvWqdravbSn/4EzvXnaLQmnaU7LoORzqNYhtiF/ILhLs96+c3pFr\n" \
"3h2652vjIjvn2bcIUuLcpy6oERlr4Kg3DkAOMoSUAQKBgQCkTg6e4Ndg1d2SySFQ\n" \
"4h7YHQZ3larxK/03DFoElNIf/6zgiNL13+9nM3l4K8YAEG1OEcn5JaBdktmGrEWR\n" \
"A+zV7Qp/hZSVuOM4sxpGa7q94A5253tvLvegIvzhFYW4WQrVFadI5xZ1HaO2Ad9I\n" \
"Kzz19+jbd085r+kyTM5X0UVzZA==\n" \
"-----END PRIVATE KEY-----\n"

// --- Camera Pin Definition ---
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM       5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// --- Global Objects ---
Preferences preferences;
FirebaseData stream_fbdo;
FirebaseData upload_fbdo; 
FirebaseAuth auth;
FirebaseConfig config;
String feederId = "";
bool streamActive = false;
bool cameraTaskStarted = false;
bool ipUploaded = false; 

enum DeviceState { PROVISIONING, CONNECTING_WIFI, AWAITING_FEEDER_ID, SYNCING_TIME, AUTHENTICATING_FIREBASE, OPERATIONAL, ERROR };
DeviceState currentState = PROVISIONING;

#if BOWL_NUMBER == 1
  HardwareSerial SerialSlave(2);
  const int RX_PIN = 12;
  const int TX_PIN = 13;
#elif BOWL_NUMBER == 2
  HardwareSerial SerialSlave(1);
  const int RX_PIN = 14;
  const int TX_PIN = 15;
#else
  #error "BOWL_NUMBER must be 1 or 2"
#endif

// --- Prototypes ---
void listenForCredentials();
void connectToWiFi();
void syncTime(); 
void startCameraServer();
void authenticateWithFirebase();
void startRTDBStream();
void streamCallback(FirebaseStream data);
void streamTimeoutCallback(bool timeout);
void tokenStatusCallback(TokenInfo info);
void listenForFeederId();
void uploadCurrentIP(); 
esp_err_t stream_handler(httpd_req_t *req);
void camera_server_task(void *pvParameters);
void performFactoryReset();
void checkSerialCommands();

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
  Serial.begin(115200);
  Serial.println("\n[PawFeeds CAM] Booting (High FPS Mode)...");
  SerialSlave.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);

  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid", "");
  feederId = preferences.getString("feederId", "");
  preferences.end();

  if (ssid.length() == 0) {
    currentState = PROVISIONING;
  } else {
    currentState = CONNECTING_WIFI;
  }
}

void performFactoryReset() {
  Serial.println("[SYSTEM] Factory Reset triggered...");
  preferences.begin("pawfeeds-cam", false);
  preferences.clear();
  preferences.end();
  delay(1000);
  ESP.restart();
}

void checkSerialCommands() {
  if (SerialSlave.available()) {
    String packet = SerialSlave.readStringUntil('\n');
    packet.trim();
    if (packet.length() > 0) {
      Serial.printf("[SERIAL] Received: %s\n", packet.c_str());
      if (packet == "RESET_DEVICE") {
        SerialSlave.println("OK");
        delay(100);
        performFactoryReset();
      }
    }
  }
}

// --- MAIN LOOP ---
void loop() {
  switch(currentState) {
    case PROVISIONING:
      listenForCredentials();
      break;
    case CONNECTING_WIFI:
      connectToWiFi();
      break;
    case AWAITING_FEEDER_ID:
      listenForFeederId();
      break;
    case SYNCING_TIME:
      syncTime();
      break;
    case AUTHENTICATING_FIREBASE:
      authenticateWithFirebase();
      break;
    case OPERATIONAL:
      if (!cameraTaskStarted) {
        Serial.println("[SYSTEM] Starting camera task on Core 1.");
        xTaskCreatePinnedToCore(camera_server_task, "CameraServer", 10000, NULL, 2, NULL, 1);
        cameraTaskStarted = true;
      }
      if (!streamActive) {
          startRTDBStream();
      }
      if (!ipUploaded && Firebase.ready() && feederId.length() > 0) {
         uploadCurrentIP();
      }
      checkSerialCommands();
      break;
    case ERROR:
      delay(5000);
      ESP.restart();
      break;
  }
  delay(100);
}

void uploadCurrentIP() {
    String ipAddress = WiFi.localIP().toString();
    
    // Using safe += concatenation
    String nodePath = "/feeders/";
    nodePath += feederId;
    nodePath += "/camIp";
    nodePath += (BOWL_NUMBER == 1 ? "1" : "2");
    
    Serial.printf("[IP SYNC] Uploading IP %s to %s\n", ipAddress.c_str(), nodePath.c_str());
    
    if (Firebase.RTDB.setString(&upload_fbdo, nodePath, ipAddress)) {
        Serial.println("[IP SYNC] IP Address uploaded successfully.");
        ipUploaded = true; 
    } else {
        Serial.printf("[IP SYNC] Failed to upload IP: %s\n", upload_fbdo.errorReason().c_str());
        ipUploaded = false; 
    }
}

void listenForCredentials() {
  if (SerialSlave.available() > 0) {
      String packet = SerialSlave.readStringUntil('\n');
      if (packet.indexOf("FEEDER_ID") != -1) return;
      
      int separator = packet.indexOf('|');
      if (separator > 0) {
        String ssid = packet.substring(0, separator);
        String pass = packet.substring(separator + 1);
        pass.trim();
        
        Serial.println("[PROVISIONING] Credentials received. Saving...");
        preferences.begin("pawfeeds-cam", false);
        preferences.putString("ssid", ssid);
        preferences.putString("pass", pass);
        preferences.end();
        SerialSlave.println("OK");
        delay(1000);
        ESP.restart();
      }
  }
}

void listenForFeederId() {
    if (SerialSlave.available() > 0) {
      String packet = SerialSlave.readStringUntil('\n');
      if (packet.startsWith("FEEDER_ID|")) {
        String receivedId = packet.substring(packet.indexOf('|') + 1);
        receivedId.trim();
        preferences.begin("pawfeeds-cam", false);
        preferences.putString("feederId", receivedId);
        preferences.end();
        feederId = receivedId;
        SerialSlave.println("OK");
        currentState = SYNCING_TIME;
      }
    }
}

void connectToWiFi() {
  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid");
  String pass = preferences.getString("pass");
  preferences.end();

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid.c_str(), pass.c_str());
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("\n[Wi-Fi] Connected! IP: ");
    Serial.println(WiFi.localIP());

    String hostname = "pawfeeds-cam-";
    hostname += BOWL_NUMBER;
    
    if (MDNS.begin(hostname.c_str())) {
        Serial.printf("[MDNS] Started: %s.local\n", hostname.c_str());
        MDNS.addService("http", "tcp", 80);
    }

    if (feederId.length() == 0) {
      currentState = AWAITING_FEEDER_ID;
    } else {
      currentState = SYNCING_TIME;
    }
  } else {
    Serial.println("\n[Wi-Fi] Failed. Rebooting.");
    ESP.restart();
  }
}

void syncTime() {
    Serial.println("[TIME] Syncing...");
    configTime(8 * 3600, 0, "pool.ntp.org", "time.nist.gov");
    time_t now = time(nullptr);
    int attempts = 0;
    while (now < 8 * 3600 * 2 && attempts < 20) {
        delay(500);
        now = time(nullptr);
        attempts++;
    }
    currentState = AUTHENTICATING_FIREBASE;
}

void authenticateWithFirebase() {
  if(Firebase.ready()) {
    currentState = OPERATIONAL;
    return;
  }
  Serial.println("[AUTH] Auth init...");
  config.database_url = FIREBASE_DATABASE_URL;
  config.service_account.data.client_email = SERVICE_ACCOUNT_CLIENT_EMAIL;
  config.service_account.data.project_id = FIREBASE_PROJECT_ID;
  config.service_account.data.private_key = SERVICE_ACCOUNT_PRIVATE_KEY;
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
}

void tokenStatusCallback(TokenInfo info) {
  if (info.status == token_status_ready) {
    Serial.println("[AUTH] Token ready.");
    currentState = OPERATIONAL;
  }
}

void startRTDBStream() {
    if (feederId.length() == 0 || !Firebase.ready()) return;
    
    String fullStreamPath = "/commands/";
    fullStreamPath += feederId;
    
    if (Firebase.RTDB.beginStream(&stream_fbdo, fullStreamPath.c_str())) {
        Firebase.RTDB.setStreamCallback(&stream_fbdo, streamCallback, streamTimeoutCallback);
        streamActive = true;
    }
}

void streamCallback(FirebaseStream data) {
    if (data.dataType() == "json") {
        FirebaseJson &json = data.to<FirebaseJson>();
        FirebaseJsonData result;
        if (json.get(result, "command")) {
            if (result.to<String>() == "reset_device") {
                String cmdPath = "/commands/";
                cmdPath += feederId;
                
                Firebase.RTDB.deleteNode(&stream_fbdo, cmdPath);
                performFactoryReset();
            }
        }
    }
}

void streamTimeoutCallback(bool timeout) {
  if (timeout) streamActive = false;
}

// --- Camera Logic ---
#define PART_BOUNDARY "12345678900000000000000000000000"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

esp_err_t stream_handler(httpd_req_t *req){
  camera_fb_t * fb = NULL;
  esp_err_t res = ESP_OK;
  size_t _jpg_buf_len = 0;
  uint8_t * _jpg_buf = NULL;
  char * part_buf[64];

  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) return res;

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) {
      res = ESP_FAIL;
      break;
    }
    
    _jpg_buf_len = fb->len;
    _jpg_buf = fb->buf;
    
    if (res == ESP_OK) res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    if (res == ESP_OK) {
      size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);
      res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);
    }
    if (res == ESP_OK) res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);
    
    esp_camera_fb_return(fb);
    if (res != ESP_OK) break;
    
    // === FPS FIX: Reduced from 100ms to 1ms ===
    // This removes the artificial 10fps cap.
    delay(1); 
  }
  return res;
}

void startCameraServer(){
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  
  config.pixel_format = PIXFORMAT_JPEG;
  
  // === OPTIMIZATION SETTINGS ===
  // 1. Resolution: CIF (400x296) - Faster than VGA, better than QVGA
  config.frame_size = FRAMESIZE_CIF;
  
  // 2. Quality: 16 - slightly lower quality for smaller packet sizes
  config.jpeg_quality = 16;
  
  // 3. Buffers: 3 - Enables "Triple Buffering" for smoother flow
  config.fb_count = 3; 
  config.fb_location = CAMERA_FB_IN_PSRAM;

  esp_camera_init(&config);

  httpd_handle_t stream_httpd = NULL;
  httpd_config_t server_config = HTTPD_DEFAULT_CONFIG();
  server_config.stack_size = 8192; 
  
  httpd_uri_t stream_uri = {
      .uri       = "/stream",
      .method    = HTTP_GET,
      .handler   = stream_handler,
      .user_ctx  = NULL
  };

  if (httpd_start(&stream_httpd, &server_config) == ESP_OK) {
      httpd_register_uri_handler(stream_httpd, &stream_uri);
  }
}

void camera_server_task(void *pvParameters) {
  startCameraServer();
  vTaskDelete(NULL);
}