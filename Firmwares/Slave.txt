#include "esp_camera.h"
#include "Arduino.h"
#include "FS.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "driver/rtc_io.h"
#include <WiFi.h>
#include <Preferences.h>
#include "esp_http_server.h"
#include <Firebase_ESP_Client.h>

// ==========================================================
// IMPORTANT: CONFIGURE THIS FOR EACH CAMERA BEFORE UPLOADING
// ==========================================================
#define BOWL_NUMBER 2 // Use 1 for the first camera, 2 for the second
// ==========================================================

// --- FIREBASE CONFIGURATION (copy from master) ---
#define FIREBASE_PROJECT_ID "pawfeeds-v2"
#define FIREBASE_DATABASE_URL "https://pawfeeds-v2-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define SERVICE_ACCOUNT_CLIENT_EMAIL "firebase-adminsdk-fbsvc@pawfeeds-v2.iam.gserviceaccount.com"
#define SERVICE_ACCOUNT_PRIVATE_KEY "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC+Sqt8BKfCEgbp\n/q4XmzzpsKwlsKJesbWN/Sp2PO7nVgPqwEz9YeCy/aI98IjyGY5hujaLLNgB0GYE\nNLvWkAf3T6VQPUa8SB28XU5sT7tfCJu/1F3yYYAVHHpbg2gbGxjgPWVlQ5arww57\nHHREzOUTRTO5k9hRAzzf1kdjBJbboewEEcIQH2uAdn+B9L58SOezjVONpr63+R5V\nWbZ7+B64BFE62Xsjcmk49OmHjKc+2ID80S6EWx6rxM5jGdTsUVtA0RISG5r1qeB/\nDazLCx1jexutuMHTogvAIirHGIMdOCW12USD8b+CRvP7Lsj6CwR91JSVm/b5P1pI\n0MNAgkfrAgMBAAECggEAO5iNHlki5P/aVHxjr5b5u8KOF3u7TmbfkmmAW+l3dNIW\nhfXV5uE5izUuE7H6YcApPGgiXvIbcG4BFT4iue7/3698+aVHOv5m+bBLOFa8OuYq\SSjMh3WLtJDnrTN5bkvNPaVc1RsW3BJJvbrKmyWEdMWOjodEDxMxhHTKhLNSP9Rq\ncTz85kc4/IsXuAD6fmApysrWiVuS+vcIzFGCjqQDozojsd58KW6XFa8PEZ95bUbE\n/Q8ZAigB88un8+87NpLd/usUk2FWHNJz523AJUA4qQE0N8J6E/7+dJbRJ9Ucg6lk\nkO0fRiLO7c7o6/7bW1iy4Yq+ph5N3+vc2pYzVZIkAQKBgQD0AbH86UoJxroGh/id\n849814dnEGugSQ1C2XCPNpQy19WtyfZvMM5yphfxfxxohJwr+KyQBcfBatGo/ipV\n9cIJUOalKa+q9KzxLsSka41cvu4RsnVjWyVqGS4w/BdYFdTvNkuK3cGiK8qYwBaW\ni50PNrcCQ+7gmMCjkPJ6LDOh6wKBgQDHpRYRXk9ipsOw4KHBxn4rph8G6ooUIvzs\nPie0e+A+pz9grNDC7y0a+k8fA4eq/iJPmu+FvuJW4fahCkt98VuW0EJjcqtBNgCB\YbOKn9H+V4WaQKCHYyhl/QxGio4qm4z34cEVt/kMGwGHlaX39RILc3kEq2RfTSc7\n2FikgZxyAQKBgQCz61wWpN5W/xXEIxaLQUCYSUQqFs2FTthcZoC82P3Fz6hbkQQJ\nUO+pUhdtltCXsNCHC8ISIHD+iYk3FtKYt7HvtJudRXOmluu+m0GcC0IdFRvuKKyu\nKlMYPKD2tatw5AgyqtJg/sr8jVXB9EGzmBajVTD0lqrZKUlCUmq480bPKQKBgQCp\nTo0qaYp1JOur4rQK+uQg7B4/5UL31LwdNJDDdJI1T+xldekMh3z+9euHZ5z0G9TJ\nIaGjEMAt4i8fXvWqdravbSn/4EzvXnaLQmnaU7LoORzqNYhtiF/ILhLs96+c3pFr\n3h2652vjIjvn2bcIUuLcpy6oERlr4Kg3DkAOMoSUAQKBgQCkTg6e4Ndg1d2SySFQ\n4h7YHQZ3larxK/03DFoElNIf/6zgiNL13+9nM3l4K8YAEG1OEcn5JaBdktmGrEWR\nA+zV7Qp/hZSVuOM4sxpGa7q94A5253tvLvegIvzhFYW4WQrVFadI5xZ1HaO2Ad9I\nKzz19+jbd085r+kyTM5X0UVzZA==\n-----END PRIVATE KEY-----\n"


// --- Camera Pin Definition for AI-THINKER MODEL ---
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// --- Global Objects ---
Preferences preferences;
FirebaseData stream_fbdo;
FirebaseAuth auth;
FirebaseConfig config;
String feederId = "";
bool streamActive = false;

// --- State Machine ---
enum DeviceState { PROVISIONING, CONNECTING_WIFI, AWAITING_FEEDER_ID, AUTHENTICATING_FIREBASE, OPERATIONAL, ERROR };
DeviceState currentState = PROVISIONING;

// --- Function Prototypes ---
void listenForCredentials();
void connectToWiFi();
void startCameraServer();
void authenticateWithFirebase();
void startRTDBStream();
void streamCallback(FirebaseStream data);
void streamTimeoutCallback(bool timeout);
void tokenStatusCallback(TokenInfo info);
void listenForFeederId();

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
  Serial.begin(115200);
  Serial.println("\n[PawFeeds CAM] Booting...");

  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid", "");
  feederId = preferences.getString("feederId", "");
  preferences.end();

  if (ssid.length() == 0) {
    currentState = PROVISIONING;
  } else if (feederId.length() == 0) {
    currentState = CONNECTING_WIFI;
  } else {
    currentState = CONNECTING_WIFI;
  }
}

void loop() {
  switch(currentState) {
    case PROVISIONING:
      listenForCredentials();
      break;
    case CONNECTING_WIFI:
      connectToWiFi();
      break;
    case AWAITING_FEEDER_ID:
      listenForFeederId();
      break;
    case AUTHENTICATING_FIREBASE:
      authenticateWithFirebase();
      break;
    case OPERATIONAL:
      if (!streamActive) {
        startRTDBStream();
      }
      if (Firebase.ready() && !Firebase.RTDB.readStream(&stream_fbdo)) {
        Serial.println("[ERROR] Stream read error!");
        streamActive = false;
      }
      break;
    case ERROR:
      Serial.println("[ERROR] Halting.");
      delay(10000);
      break;
  }
  delay(100);
}

void listenForCredentials() {
  Serial.println("[PROVISIONING] No credentials found. Listening for Master...");
  Serial.begin(9600);
  while (currentState == PROVISIONING) {
    if (Serial.available() > 0) {
      String packet = Serial.readStringUntil('\n');
      if (packet.indexOf("FEEDER_ID") != -1) continue; // Ignore feeder ID packets for now
      
      int separator = packet.indexOf('|');
      if (separator > 0) {
        String ssid = packet.substring(0, separator);
        String pass = packet.substring(separator + 1);
        pass.trim();
        
        Serial.begin(115200);
        Serial.println("\n[PROVISIONING] Wi-Fi Credentials received! Saving...");
        
        preferences.begin("pawfeeds-cam", false);
        preferences.putString("ssid", ssid);
        preferences.putString("pass", pass);
        preferences.end();

        Serial.println("[PROVISIONING] Saved. Rebooting to connect...");
        delay(1000);
        ESP.restart();
      }
    }
    delay(100);
  }
}

void listenForFeederId() {
  Serial.println("[PROVISIONING] Awaiting Feeder ID from Master...");
  Serial.begin(9600);
  while(currentState == AWAITING_FEEDER_ID) {
    if (Serial.available() > 0) {
      String packet = Serial.readStringUntil('\n');
      if (packet.startsWith("FEEDER_ID|")) {
        String receivedId = packet.substring(packet.indexOf('|') + 1);
        receivedId.trim();
        
        Serial.begin(115200);
        Serial.printf("[PROVISIONING] Feeder ID received: %s. Saving...\n", receivedId.c_str());

        preferences.begin("pawfeeds-cam", false);
        preferences.putString("feederId", receivedId);
        preferences.end();
        feederId = receivedId;

        Serial.println("[PROVISIONING] Feeder ID saved. Proceeding to Firebase Auth.");
        currentState = AUTHENTICATING_FIREBASE;
      }
    }
    delay(100);
  }
}

void connectToWiFi() {
  Serial.begin(115200);
  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid");
  String pass = preferences.getString("pass");
  preferences.end();

  WiFi.begin(ssid.c_str(), pass.c_str());
  Serial.print("[Wi-Fi] Connecting to ");
  Serial.print(ssid);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("\n[Wi-Fi] Connected! IP Address: ");
    Serial.println(WiFi.localIP());
    startCameraServer(); // Start camera stream in parallel

    if (feederId.length() == 0) {
      currentState = AWAITING_FEEDER_ID;
    } else {
      currentState = AUTHENTICATING_FIREBASE;
    }
  } else {
    Serial.println("\n[Wi-Fi] Failed to connect. Clearing credentials and rebooting.");
    preferences.begin("pawfeeds-cam", false);
    preferences.clear();
    preferences.end();
    delay(1000);
    ESP.restart();
  }
}

void authenticateWithFirebase() {
  if(Firebase.ready()) {
    currentState = OPERATIONAL;
    return;
  }
  Serial.println("[AUTH] Configuring Firebase service account...");
  config.database_url = FIREBASE_DATABASE_URL;
  config.service_account.data.client_email = SERVICE_ACCOUNT_CLIENT_EMAIL;
  config.service_account.data.project_id = FIREBASE_PROJECT_ID;
  config.service_account.data.private_key = SERVICE_ACCOUNT_PRIVATE_KEY;
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  
  if(Firebase.ready()){
    currentState = OPERATIONAL;
  }
}

void tokenStatusCallback(TokenInfo info) {
  if (info.status == token_status_ready) {
    Serial.println("[AUTH] Token obtained successfully.");
    currentState = OPERATIONAL;
  } else {
    Serial.printf("[AUTH] Token error: %s\n", info.error.message.c_str());
  }
}

void startRTDBStream() {
    if (feederId.length() == 0 || !Firebase.ready()) return;
    String fullStreamPath = "/commands/";
    fullStreamPath.concat(feederId);

    Serial.print("[STREAM] Starting stream on path: ");
    Serial.println(fullStreamPath);

    if (!Firebase.RTDB.beginStream(&stream_fbdo, fullStreamPath.c_str())) {
        Serial.printf("[STREAM] Could not begin stream: %s\n", stream_fbdo.errorReason().c_str());
        return;
    }
    Firebase.RTDB.setStreamCallback(&stream_fbdo, streamCallback, streamTimeoutCallback);
    streamActive = true;
    Serial.println("[STREAM] RTDB Stream started successfully.");
}

void streamCallback(FirebaseStream data) {
    Serial.printf("[STREAM] Event: %s, Path: %s\n", data.eventType().c_str(), data.dataPath().c_str());
    if (data.dataType() == "json" && data.dataPath() == "/") {
        FirebaseJson &json = data.to<FirebaseJson>();
        FirebaseJsonData result;
        String command;
        if (json.get(result, "command")) {
            command = result.to<String>();
        }

        if (command == "reset_device") {
            Serial.println("[SYSTEM] Reset command received. Clearing ALL credentials and restarting.");
            preferences.begin("pawfeeds-cam", false);
            preferences.clear();
            preferences.end();
            delay(500);
            ESP.restart();
        }
    }
}

void streamTimeoutCallback(bool timeout) {
  if (timeout) {
    Serial.println("[STREAM] Stream timed out. It will be restarted automatically.");
    streamActive = false;
  }
}

void startCameraServer(){
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG; 
  config.frame_size = FRAMESIZE_VGA;
  config.jpeg_quality = 12;
  config.fb_count = 2;

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  httpd_handle_t stream_httpd = NULL;
  httpd_config_t server_config = HTTPD_DEFAULT_CONFIG();
  httpd_uri_t stream_uri = {
      .uri       = "/stream",
      .method    = HTTP_GET,
      .handler   = [](httpd_req_t *req){
        camera_fb_t * fb = NULL;
        esp_err_t res = ESP_OK;
        size_t _jpg_buf_len = 0;
        uint8_t * _jpg_buf = NULL;
        char * part_buf[64];

        res = httpd_resp_set_type(req, "multipart/x-mixed-replace;boundary=--FRAME");
        if(res != ESP_OK){ return res; }

        while(true){
          fb = esp_camera_fb_get();
          if (!fb) { res = ESP_FAIL; } 
          else {
            if(fb->format != PIXFORMAT_JPEG){
              bool jpeg_converted = frame2jpg(fb, 80, &_jpg_buf, &_jpg_buf_len);
              esp_camera_fb_return(fb);
              fb = NULL;
              if(!jpeg_converted){ res = ESP_FAIL; }
            } else {
              _jpg_buf_len = fb->len;
              _jpg_buf = fb->buf;
            }
          }
          if(res == ESP_OK){
            size_t hlen = snprintf((char *)part_buf, 64, "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n", _jpg_buf_len);
            res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);
          }
          if(res == ESP_OK){ res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len); }
          if(res == ESP_OK){ res = httpd_resp_send_chunk(req, "\r\n--FRAME\r\n", 11); }
          if(fb){
            esp_camera_fb_return(fb);
            fb = NULL;
            _jpg_buf = NULL;
          } else if(_jpg_buf){
            free(_jpg_buf);
            _jpg_buf = NULL;
          }
          if(res != ESP_OK){ break; }
        }
        return res;
      },
      .user_ctx  = NULL
  };
  if (httpd_start(&stream_httpd, &server_config) == ESP_OK) {
      httpd_register_uri_handler(stream_httpd, &stream_uri);
  }
    Serial.print("[STREAM] Camera stream server started at http://");
    Serial.print(WiFi.localIP());
    Serial.println("/stream");
}