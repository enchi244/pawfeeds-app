#include "esp_camera.h"
#include "Arduino.h"
#include "FS.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "driver/rtc_io.h"
#include <WiFi.h>
#include <Preferences.h>
#include "esp_http_server.h"
#include <Firebase_ESP_Client.h>

// ==========================================================
// IMPORTANT: CONFIGURE THIS FOR EACH CAMERA BEFORE UPLOADING
// ==========================================================
#define BOWL_NUMBER 1 // Use 1 for the first camera, 2 for the second
// ==========================================================

// --- FIREBASE CONFIGURATION (copy from master) ---
#define FIREBASE_PROJECT_ID "pawfeeds-v2"
#define FIREBASE_DATABASE_URL "https://pawfeeds-v2-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define SERVICE_ACCOUNT_CLIENT_EMAIL "firebase-adminsdk-fbsvc@pawfeeds-v2.iam.gserviceaccount.com"
#define SERVICE_ACCOUNT_PRIVATE_KEY "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC+Sqt8BKfCEgbp\n/q4XmzzpsKwlsKJesbWN/Sp2PO7nVgPqwEz9YeCy/aI98IjyGY5hujaLLNgB0GYE\nNLvWkAf3T6VQPUa8SB28XU5sT7tfCJu/1F3yYYAVHHpbg2gbGxjgPWVlQ5arww57\nHHREzOUTRTO5k9hRAzzf1kdjBJbboewEEcIQH2uAdn+B9L58SOezjVONpr63+R5V\nWbZ7+B64BFE62Xsjcmk49OmHjKc+2ID80S6EWx6rxM5jGdTsUVtA0RISG5r1qeB/\nDazLCx1jexutuMHTogvAIirHGIMdOCW12USD8b+CRvP7Lsj6CwR91JSVm/b5P1pI\n0MNAgkfrAgMBAAECggEAO5iNHlki5P/aVHxjr5b5u8KOF3u7TmbfkmmAW+l3dNIW\nhfXV5uE5izUuE7H6YcApPGgiXvIbcG4BFT4iue7/3698+aVHOv5m+bBLOFa8OuYq\nSSjMh3WLtJDnrTN5bkvNPaVc1RsW3BJJvbrKmyWEdMWOjodEDxMxhHTKhLNSP9Rq\ncTz85kc4/IsXuAD6fmApysrWiVuS+vcIzFGCjqQDozojsd58KW6XFa8PEZ95bUbE\n/Q8ZAigB88un8+87NpLd/usUk2FWHNJz523AJUA4qQE0N8J6E/7+dJbRJ9Ucg6lk\nkO0fRiLO7c7o6/7bW1iy4Yq+ph5N3+vc2pYzVZIkAQKBgQD0AbH86UoJxroGh/id\n849814dnEGugSQ1C2XCPNpQy19WtyfZvMM5yphfxfxxohJwr+KyQBcfBatGo/ipV\n9cIJUOalKa+q9KzxLsSka41cvu4RsnVjWyVqGS4w/BdYFdTvNkuK3cGiK8qYwBaW\ni50PNrcCQ+7gmMCjkPJ6LDOh6wKBgQDHpRYRXk9ipsOw4KHBxn4rph8G6ooUIvzs\nPie0e+A+pz9grNDC7y0a+k8fA4eq/iJPmu+FvuJW4fahCkt98VuW0EJjcqtBNgCB\nYbOKn9H+V4WaQKCHYyhl/QxGio4qm4z34cEVt/kMGwGHlaX39RILc3kEq2RfTSc7\n2FikgZxyAQKBgQCz61wWpN5W/xXEIxaLQUCYSUQqFs2FTthcZoC82P3Fz6hbkQQJ\nUO+pUhdtltCXsNCHC8ISIHD+iYk3FtKYt7HvtJudRXOmluu+m0GcC0IdFRvuKKyu\nKlMYPKD2tatw5AgyqtJg/sr8jVXB9EGzmBajVTD0lqrZKUlCUmq480bPKQKBgQCp\nTo0qaYp1JOur4rQK+uQg7B4/5UL31LwdNJDDdJI1T+xldekMh3z+9euHZ5z0G9TJ\nIaGjEMAt4i8fXvWqdravbSn/4EzvXnaLQmnaU7LoORzqNYhtiF/ILhLs96+c3pFr\n3h2652vjIjvn2bcIUuLcpy6oERlr4Kg3DkAOMoSUAQKBgQCkTg6e4Ndg1d2SySFQ\n4h7YHQZ3larxK/03DFoElNIf/6zgiNL13+9nM3l4K8YAEG1OEcn5JaBdktmGrEWR\nA+zV7Qp/hZSVuOM4sxpGa7q94A5253tvLvegIvzhFYW4WQrVFadI5xZ1HaO2Ad9I\nKzz19+jbd085r+kyTM5X0UVzZA==\n-----END PRIVATE KEY-----\n"
  
// --- Camera Pin Definition for AI-THINKER MODEL ---
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// --- Global Objects ---
Preferences preferences;
FirebaseData stream_fbdo;
FirebaseAuth auth;
FirebaseConfig config;
String feederId = "";
bool streamActive = false;
// --- State Machine ---
enum DeviceState { PROVISIONING, CONNECTING_WIFI, AWAITING_FEEDER_ID, AUTHENTICATING_FIREBASE, OPERATIONAL, ERROR };
DeviceState currentState = PROVISIONING;
#if BOWL_NUMBER == 1
  // For Bowl 1, use UART2 to match Master's Serial2.
  HardwareSerial SerialSlave(2);
  const int RX_PIN = 12; // Connect to Master's TX (GPIO 13)
  const int TX_PIN = 13; // Connect to Master's RX (GPIO 12)
#elif BOWL_NUMBER == 2
  // For Bowl 2, use UART1 to match Master's Serial1.
  HardwareSerial SerialSlave(1);
  const int RX_PIN = 14; // Connect to Master's TX (GPIO 15)
  const int TX_PIN = 15; // Connect to Master's RX (GPIO 14)
#else
  #error "BOWL_NUMBER must be 1 or 2"
#endif


// --- Function Prototypes ---
void listenForCredentials();
void connectToWiFi();
void startCameraServer();
void authenticateWithFirebase();
void startRTDBStream();
void streamCallback(FirebaseStream data);
void streamTimeoutCallback(bool timeout);
void tokenStatusCallback(TokenInfo info);
void listenForFeederId();
esp_err_t stream_handler(httpd_req_t *req);

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
  Serial.begin(115200); // For Debugging
  Serial.println("\n[PawFeeds CAM] Booting...");

  SerialSlave.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);

  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid", "");
  feederId = preferences.getString("feederId", "");
  preferences.end();
  if (ssid.length() == 0) {
    currentState = PROVISIONING;
  } else if (feederId.length() == 0) {
    currentState = CONNECTING_WIFI;
  } else {
    currentState = CONNECTING_WIFI;
  }
}

void loop() {
  switch(currentState) {
    case PROVISIONING:
      listenForCredentials();
      break;
    case CONNECTING_WIFI:
      connectToWiFi();
      break;
    case AWAITING_FEEDER_ID:
      listenForFeederId();
      break;
    case AUTHENTICATING_FIREBASE:
      authenticateWithFirebase();
      break;
    case OPERATIONAL:
      if (!streamActive) {
        startRTDBStream();
      }
      if (Firebase.ready() && !Firebase.RTDB.readStream(&stream_fbdo)) {
        Serial.println("[ERROR] Stream read error!");
        streamActive = false;
      }
      break;
    case ERROR:
      Serial.println("[ERROR] Halting.");
      delay(10000);
      break;
  }
  delay(100);
}

void listenForCredentials() {
  Serial.println("[PROVISIONING] No credentials found. Listening for Master...");
  while (currentState == PROVISIONING) {
    if (SerialSlave.available() > 0) {
      String packet = SerialSlave.readStringUntil('\n');
      if (packet.indexOf("FEEDER_ID") != -1) continue; // Ignore feeder ID packets for now
      
      int separator = packet.indexOf('|');
      if (separator > 0) {
        String ssid = packet.substring(0, separator);
        String pass = packet.substring(separator + 1);
        pass.trim();
        
        Serial.println("\n[PROVISIONING] Wi-Fi Credentials received! Saving...");
        
        preferences.begin("pawfeeds-cam", false);
        preferences.putString("ssid", ssid);
        preferences.putString("pass", pass);
        preferences.end();

        SerialSlave.println("OK");
        // Acknowledge receipt

        Serial.println("[PROVISIONING] Saved. Rebooting to connect...");
        delay(1000);
        ESP.restart();
      }
    }
    delay(100);
  }
}

void listenForFeederId() {
  Serial.println("[PROVISIONING] Awaiting Feeder ID from Master...");
  while(currentState == AWAITING_FEEDER_ID) {
    if (SerialSlave.available() > 0) {
      String packet = SerialSlave.readStringUntil('\n');
      if (packet.startsWith("FEEDER_ID|")) {
        String receivedId = packet.substring(packet.indexOf('|') + 1);
        receivedId.trim();
        Serial.printf("[PROVISIONING] Feeder ID received: %s. Saving...\n", receivedId.c_str());

        preferences.begin("pawfeeds-cam", false);
        preferences.putString("feederId", receivedId);
        preferences.end();
        feederId = receivedId;

        SerialSlave.println("OK");
        // Acknowledge receipt
        
        Serial.println("[PROVISIONING] Feeder ID saved. Proceeding to Firebase Auth.");
        currentState = AUTHENTICATING_FIREBASE;
      }
    }
    delay(100);
  }
}

void connectToWiFi() {
  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid");
  String pass = preferences.getString("pass");
  preferences.end();

  WiFi.begin(ssid.c_str(), pass.c_str());
  Serial.print("[Wi-Fi] Connecting to ");
  Serial.print(ssid);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("\n[Wi-Fi] Connected! IP Address: ");
    Serial.println(WiFi.localIP());
    startCameraServer();
    // Start camera stream in parallel

    if (feederId.length() == 0) {
      currentState = AWAITING_FEEDER_ID;
    } else {
      currentState = AUTHENTICATING_FIREBASE;
    }
  } else {
    Serial.println("\n[Wi-Fi] Failed to connect. Clearing credentials and rebooting.");
    preferences.begin("pawfeeds-cam", false);
    preferences.clear();
    preferences.end();
    delay(1000);
    ESP.restart();
  }
}

void authenticateWithFirebase() {
  if(Firebase.ready()) {
    currentState = OPERATIONAL;
    return;
  }
  Serial.println("[AUTH] Configuring Firebase service account...");
  config.database_url = FIREBASE_DATABASE_URL;
  config.service_account.data.client_email = SERVICE_ACCOUNT_CLIENT_EMAIL;
  config.service_account.data.project_id = FIREBASE_PROJECT_ID;
  config.service_account.data.private_key = SERVICE_ACCOUNT_PRIVATE_KEY;
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  
  if(Firebase.ready()){
    currentState = OPERATIONAL;
  }
}

void tokenStatusCallback(TokenInfo info) {
  if (info.status == token_status_ready) {
    Serial.println("[AUTH] Token obtained successfully.");
    currentState = OPERATIONAL;
  } else {
    Serial.printf("[AUTH] Token error: %s\n", info.error.message.c_str());
  }
}

void startRTDBStream() {
    if (feederId.length() == 0 || !Firebase.ready()) return;
    String fullStreamPath = "/commands/";
    fullStreamPath.concat(feederId);
    Serial.print("[STREAM] Starting stream on path: ");
    Serial.println(fullStreamPath);

    if (!Firebase.RTDB.beginStream(&stream_fbdo, fullStreamPath.c_str())) {
        Serial.printf("[STREAM] Could not begin stream: %s\n", stream_fbdo.errorReason().c_str());
        return;
    }
    Firebase.RTDB.setStreamCallback(&stream_fbdo, streamCallback, streamTimeoutCallback);
    streamActive = true;
    Serial.println("[STREAM] RTDB Stream started successfully.");
}

void streamCallback(FirebaseStream data) {
    Serial.printf("[STREAM] Event: %s, Path: %s\n", data.eventType().c_str(), data.dataPath().c_str());
    if (data.dataType() == "json" && data.dataPath() == "/") {
        FirebaseJson &json = data.to<FirebaseJson>();
        FirebaseJsonData result;
        String command;
        if (json.get(result, "command")) {
            command = result.to<String>();
        }

        if (command == "reset_device") {
            Serial.println("[SYSTEM] Reset command received. Clearing ALL credentials and restarting.");
            // Delete the command from the database before restarting
            String fullStreamPath = "/commands/";
            fullStreamPath.concat(feederId);
            Firebase.RTDB.deleteNode(&stream_fbdo, fullStreamPath.c_str());

            preferences.begin("pawfeeds-cam", false);
            preferences.clear();
            preferences.end();
            delay(500);
            ESP.restart();
        }
    }
}

void streamTimeoutCallback(bool timeout) {
  if (timeout) {
    Serial.println("[STREAM] Stream timed out. It will be restarted automatically.");
    streamActive = false;
  }
}

// +++ FIX: Corrected MJPEG streaming handler with detailed logging +++
#define PART_BOUNDARY "12345678900000000000000000000000"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

esp_err_t stream_handler(httpd_req_t *req){
  camera_fb_t * fb = NULL;
  esp_err_t res = ESP_OK;
  size_t _jpg_buf_len = 0;
  uint8_t * _jpg_buf = NULL;
  char * part_buf[64];

  Serial.println("[STREAM HANDLER] Client connected.");

  // Set initial response headers for the MJPEG stream
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) {
    Serial.printf("[STREAM HANDLER] ERROR: Failed to set response type with code %d\n", res);
    return res;
  }
  
  // Add headers to prevent caching
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache, no-store, must-revalidate");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.println("[STREAM HANDLER] ERROR: Camera frame capture failed.");
      res = ESP_FAIL;
      break; // Exit loop immediately on failure
    }
    
    _jpg_buf_len = fb->len;
    _jpg_buf = fb->buf;
    
    Serial.printf("[STREAM HANDLER] Frame captured. Size: %zu bytes\n", _jpg_buf_len);

    // Send the boundary string
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    }
    // Send the part headers
    if (res == ESP_OK) {
      size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);
      res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);
    }
    // Send the JPEG image data
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);
    }
    
    // Return the frame buffer to be reused
    esp_camera_fb_return(fb);

    // If any of the send operations failed, break the loop
    if (res != ESP_OK) {
      Serial.printf("[STREAM HANDLER] ERROR: Send chunk failed with code %d. Breaking loop.\n", res);
      break;
    }
  }

  Serial.println("[STREAM HANDLER] Client disconnected or error occurred. Ending stream response.");
  httpd_resp_send_chunk(req, NULL, 0); // Finalize the response
  return res;
}

void startCameraServer(){
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG; 
  config.frame_size = FRAMESIZE_VGA;
  config.jpeg_quality = 12;
  config.fb_count = 2;

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  httpd_handle_t stream_httpd = NULL;
  httpd_config_t server_config = HTTPD_DEFAULT_CONFIG();

  httpd_uri_t stream_uri = {
      .uri       = "/stream",
      .method    = HTTP_GET,
      .handler   = stream_handler,
      .user_ctx  = NULL
  };
  
  if (httpd_start(&stream_httpd, &server_config) == ESP_OK) {
      httpd_register_uri_handler(stream_httpd, &stream_uri);
  }
    Serial.print("[STREAM] Camera stream server started at http://");
    Serial.print(WiFi.localIP());
    Serial.println("/stream");
}