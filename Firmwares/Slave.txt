#include "esp_camera.h"
#include "Arduino.h"
#include "FS.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "driver/rtc_io.h"
#include <WiFi.h>
#include <Preferences.h>
#include "esp_http_server.h"
#include <Firebase_ESP_Client.h>
#include <time.h> 

// --- DNS FIX: Include the low-level DNS libraries ---
#include "lwip/dns.h"
#include "lwip/ip_addr.h"

// ==========================================================
// IMPORTANT: CONFIGURE THIS FOR EACH CAMERA BEFORE UPLOADING
// ==========================================================
#define BOWL_NUMBER 2 // Use 1 for the first camera, 2 for the second
// ==========================================================

// --- FIREBASE CONFIGURATION (copy from master) ---
#define FIREBASE_PROJECT_ID "pawfeeds-v2"
#define FIREBASE_DATABASE_URL "https://pawfeeds-v2-default-rtdb.asia-southeast1.firebasedatabase.app/"
#define SERVICE_ACCOUNT_CLIENT_EMAIL "firebase-adminsdk-fbsvc@pawfeeds-v2.iam.gserviceaccount.com"

// --- FIX: Re-formatted private key for C++ compiler compliance ---
#define SERVICE_ACCOUNT_PRIVATE_KEY "-----BEGIN PRIVATE KEY-----\n" \
"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC+Sqt8BKfCEgbp\n" \
"/q4XmzzpsKwlsKJesbWN/Sp2PO7nVgPqwEz9YeCy/aI98IjyGY5hujaLLNgB0GYE\n" \
"NLvWkAf3T6VQPUa8SB28XU5sT7tfCJu/1F3yYYAVHHpbg2gbGxjgPWVlQ5arww57\n" \
"HHREzOUTRTO5k9hRAzzf1kdjBJbboewEEcIQH2uAdn+B9L58SOezjVONpr63+R5V\n" \
"WbZ7+B64BFE62Xsjcmk49OmHjKc+2ID80S6EWx6rxM5jGdTsUVtA0RISG5r1qeB/\n" \
"DazLCx1jexutuMHTogvAIirHGIMdOCW12USD8b+CRvP7Lsj6CwR91JSVm/b5P1pI\n" \
"0MNAgkfrAgMBAAECggEAO5iNHlki5P/aVHxjr5b5u8KOF3u7TmbfkmmAW+l3dNIW\n" \
"hfXV5uE5izUuE7H6YcApPGgiXvIbcG4BFT4iue7/3698+aVHOv5m+bBLOFa8OuYq\n" \
"SSjMh3WLtJDnrTN5bkvNPaVc1RsW3BJJvbrKmyWEdMWOjodEDxMxhHTKhLNSP9Rq\n" \
"cTz85kc4/IsXuAD6fmApysrWiVuS+vcIzFGCjqQDozojsd58KW6XFa8PEZ95bUbE\n" \
"/Q8ZAigB88un8+87NpLd/usUk2FWHNJz523AJUA4qQE0N8J6E/7+dJbRJ9Ucg6lk\n" \
"kO0fRiLO7c7o6/7bW1iy4Yq+ph5N3+vc2pYzVZIkAQKBgQD0AbH86UoJxroGh/id\n" \
"849814dnEGugSQ1C2XCPNpQy19WtyfZvMM5yphfxfxxohJwr+KyQBcfBatGo/ipV\n" \
"9cIJUOalKa+q9KzxLsSka41cvu4RsnVjWyVqGS4w/BdYFdTvNkuK3cGiK8qYwBaW\n" \
"i50PNrcCQ+7gmMCjkPJ6LDOh6wKBgQDHpRYRXk9ipsOw4KHBxn4rph8G6ooUIvzs\n" \
"Pie0e+A+pz9grNDC7y0a+k8fA4eq/iJPmu+FvuJW4fahCkt98VuW0EJjcqtBNgCB\n" \
"YbOKn9H+V4WaQKCHYyhl/QxGio4qm4z34cEVt/kMGwGHlaX39RILc3kEq2RfTSc7\n" \
"2FikgZxyAQKBgQCz61wWpN5W/xXEIxaLQUCYSUQqFs2FTthcZoC82P3Fz6hbkQQJ\n" \
"UO+pUhdtltCXsNCHC8ISIHD+iYk3FtKYt7HvtJudRXOmluu+m0GcC0IdFRvuKKyu\n" \
"KlMYPKD2tatw5AgyqtJg/sr8jVXB9EGzmBajVTD0lqrZKUlCUmq480bPKQKBgQCp\n" \
"To0qaYp1JOur4rQK+uQg7B4/5UL31LwdNJDDdJI1T+xldekMh3z+9euHZ5z0G9TJ\n" \
"IaGjEMAt4i8fXvWqdravbSn/4EzvXnaLQmnaU7LoORzqNYhtiF/ILhLs96+c3pFr\n" \
"3h2652vjIjvn2bcIUuLcpy6oERlr4Kg3DkAOMoSUAQKBgQCkTg6e4Ndg1d2SySFQ\n" \
"4h7YHQZ3larxK/03DFoElNIf/6zgiNL13+9nM3l4K8YAEG1OEcn5JaBdktmGrEWR\n" \
"A+zV7Qp/hZSVuOM4sxpGa7q94A5253tvLvegIvzhFYW4WQrVFadI5xZ1HaO2Ad9I\n" \
"Kzz19+jbd085r+kyTM5X0UVzZA==\n" \
"-----END PRIVATE KEY-----\n"

// --- Camera Pin Definition for AI-THINKER MODEL ---
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// --- Global Objects ---
Preferences preferences;
FirebaseData stream_fbdo;
FirebaseAuth auth;
FirebaseConfig config;
String feederId = "";
bool streamActive = false;
bool cameraTaskStarted = false;

// --- State Machine ---
enum DeviceState { PROVISIONING, CONNECTING_WIFI, AWAITING_FEEDER_ID, SYNCING_TIME, AUTHENTICATING_FIREBASE, OPERATIONAL, ERROR };
DeviceState currentState = PROVISIONING;

#if BOWL_NUMBER == 1
  HardwareSerial SerialSlave(2);
  const int RX_PIN = 12;
  const int TX_PIN = 13;
#elif BOWL_NUMBER == 2
  HardwareSerial SerialSlave(1);
  const int RX_PIN = 14;
  const int TX_PIN = 15;
#else
  #error "BOWL_NUMBER must be 1 or 2"
#endif

// --- Function Prototypes ---
void listenForCredentials();
void connectToWiFi();
void syncTime(); 
void startCameraServer();
void authenticateWithFirebase();
void startRTDBStream();
void streamCallback(FirebaseStream data);
void streamTimeoutCallback(bool timeout);
void tokenStatusCallback(TokenInfo info);
void listenForFeederId();
esp_err_t stream_handler(httpd_req_t *req);
void camera_server_task(void *pvParameters);


void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
  Serial.begin(115200);
  Serial.println("\n[PawFeeds CAM] Booting (Optimized Firmware)...");
  SerialSlave.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);

  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid", "");
  feederId = preferences.getString("feederId", "");
  preferences.end();

  if (ssid.length() == 0) {
    currentState = PROVISIONING;
  } else {
    currentState = CONNECTING_WIFI;
  }
}

// The main loop runs implicitly on Core 0, handling Firebase and general logic.
void loop() {
  switch(currentState) {
    case PROVISIONING:
      listenForCredentials();
      break;
    case CONNECTING_WIFI:
      connectToWiFi();
      break;
    case AWAITING_FEEDER_ID:
      listenForFeederId();
      break;
    case SYNCING_TIME:
      syncTime();
      break;
    case AUTHENTICATING_FIREBASE:
      authenticateWithFirebase();
      break;
    case OPERATIONAL:
      if (!cameraTaskStarted) {
        Serial.println("[SYSTEM] Firebase is ready. Starting camera task on Core 1.");
        xTaskCreatePinnedToCore(
          camera_server_task,
          "CameraServer",
          10000,
          NULL,
          2,
          NULL,
          1
        );
        cameraTaskStarted = true;
      }

      // ===================================================================
      // === THIS IS THE FIX: Disable the RTDB stream ======================
      // ===================================================================
      // By commenting out this block, Core 0 is now free and will not
      // compete with Core 1 for network resources, which was causing
      // the "Send chunk failed" error.
      /*
      if (!streamActive) {
        startRTDBStream();
      }
      if (Firebase.ready() && !Firebase.RTDB.readStream(&stream_fbdo)) {
        Serial.println("[ERROR] Stream read error!");
        streamActive = false;
      }
      */
      // ===================================================================
      // === END OF FIX ====================================================
      // ===================================================================
      break;
    case ERROR:
      Serial.println("[ERROR] Halting.");
      delay(10000);
      break;
  }
  delay(100);
}

void listenForCredentials() {
  Serial.println("[PROVISIONING] No credentials found. Listening for Master...");
  while (currentState == PROVISIONING) {
    if (SerialSlave.available() > 0) {
      String packet = SerialSlave.readStringUntil('\n');
      if (packet.indexOf("FEEDER_ID") != -1) continue;
      
      int separator = packet.indexOf('|');
      if (separator > 0) {
        String ssid = packet.substring(0, separator);
        String pass = packet.substring(separator + 1);
        pass.trim();
        
        Serial.println("\n[PROVISIONING] Wi-Fi Credentials received! Saving...");
        
        preferences.begin("pawfeeds-cam", false);
        preferences.putString("ssid", ssid);
        preferences.putString("pass", pass);
        preferences.end();

        SerialSlave.println("OK");
        Serial.println("[PROVISIONING] Saved. Rebooting to connect...");
        delay(1000);
        ESP.restart();
      }
    }
    delay(100);
  }
}

void listenForFeederId() {
  Serial.println("[PROVISIONING] Awaiting Feeder ID from Master...");
  while(currentState == AWAITING_FEEDER_ID) {
    if (SerialSlave.available() > 0) {
      String packet = SerialSlave.readStringUntil('\n');
      if (packet.startsWith("FEEDER_ID|")) {
        String receivedId = packet.substring(packet.indexOf('|') + 1);
        receivedId.trim();
        Serial.printf("[PROVISIONING] Feeder ID received: %s. Saving...\n", receivedId.c_str());

        preferences.begin("pawfeeds-cam", false);
        preferences.putString("feederId", receivedId);
        preferences.end();
        feederId = receivedId;

        SerialSlave.println("OK");
        Serial.println("[PROVISIONING] Feeder ID saved. Proceeding to Firebase Auth.");
        
        currentState = SYNCING_TIME;
      }
    }
    delay(100);
  }
}

void connectToWiFi() {
  preferences.begin("pawfeeds-cam", true);
  String ssid = preferences.getString("ssid");
  String pass = preferences.getString("pass");
  preferences.end();

  IPAddress primaryDNS(8, 8, 8, 8);
  IPAddress secondaryDNS(8, 8, 4, 4);
  IPAddress ip(0, 0, 0, 0);
  IPAddress gateway(0, 0, 0, 0);
  IPAddress subnet(0, 0, 0, 0);

  if (!WiFi.config(ip, gateway, subnet, primaryDNS, secondaryDNS)) {
    Serial.println("[ERROR] WiFi.config() failed. Halting.");
    currentState = ERROR;
    return;
  }
  
  WiFi.begin(ssid.c_str(), pass.c_str());
  Serial.print("[Wi-Fi] Connecting to ");
  Serial.print(ssid);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("\n[Wi-Fi] Connected! IP Address: ");
    Serial.println(WiFi.localIP());
    
    if (feederId.length() == 0) {
      currentState = AWAITING_FEEDER_ID;
    } else {
      currentState = SYNCING_TIME;
    }
  } else {
    Serial.println("\n[Wi-Fi] Failed to connect. Clearing credentials and rebooting.");
    preferences.begin("pawfeeds-cam", false);
    preferences.clear();
    preferences.end();
    delay(1000);
    ESP.restart();
  }
}

void syncTime() {
    Serial.println("[TIME] Syncing with NTP server...");
    configTime(8 * 3600, 0, "pool.ntp.org", "time.nist.gov");
    
    time_t now = time(nullptr);
    int attempts = 0;
    while (now < 8 * 3600 * 2 && attempts < 60) {
        delay(500);
        Serial.print(".");
        now = time(nullptr);
        attempts++;
    }

    if (now < 8 * 3600 * 2) {
        Serial.println("\n[TIME] Failed to sync time!");
        currentState = ERROR;
    } else {
        struct tm timeinfo;
        gmtime_r(&now, &timeinfo);
        Serial.print("\n[TIME] Time synced successfully: ");
        Serial.print(asctime(&timeinfo));
        currentState = AUTHENTICATING_FIREBASE;
    }
}

void authenticateWithFirebase() {
  if(Firebase.ready()) {
    currentState = OPERATIONAL;
    return;
  }
  Serial.println("[AUTH] Configuring Firebase service account...");
  config.database_url = FIREBASE_DATABASE_URL;
  config.service_account.data.client_email = SERVICE_ACCOUNT_CLIENT_EMAIL;
  config.service_account.data.project_id = FIREBASE_PROJECT_ID;
  config.service_account.data.private_key = SERVICE_ACCOUNT_PRIVATE_KEY;
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
}

void tokenStatusCallback(TokenInfo info) {
  if (info.status == token_status_ready) {
    Serial.println("[AUTH] Token obtained successfully.");
    currentState = OPERATIONAL;
  } else {
    Serial.printf("[AUTH] Token error: %s\n", info.error.message.c_str());
  }
}

void startRTDBStream() {
    if (feederId.length() == 0 || !Firebase.ready()) return;
    String fullStreamPath = "/commands/";
    fullStreamPath.concat(feederId);
    Serial.print("[STREAM] Starting RTDB stream on path: ");
    Serial.println(fullStreamPath);

    if (!Firebase.RTDB.beginStream(&stream_fbdo, fullStreamPath.c_str())) {
        Serial.printf("[STREAM] Could not begin stream: %s\n", stream_fbdo.errorReason().c_str());
        return;
    }
    Firebase.RTDB.setStreamCallback(&stream_fbdo, streamCallback, streamTimeoutCallback);
    streamActive = true;
    Serial.println("[STREAM] RTDB Stream started successfully.");
}

void streamCallback(FirebaseStream data) {
    Serial.printf("[STREAM] Event: %s, Path: %s\n", data.eventType().c_str(), data.dataPath().c_str());
    if (data.dataType() == "json" && data.dataPath() == "/") {
        FirebaseJson &json = data.to<FirebaseJson>();
        FirebaseJsonData result;
        String command;
        if (json.get(result, "command")) {
            command = result.to<String>();
        }

        if (command == "reset_device") {
            Serial.println("[SYSTEM] Reset command received. Clearing ALL credentials and restarting.");
            String fullStreamPath = "/commands/";
            fullStreamPath.concat(feederId);
            Firebase.RTDB.deleteNode(&stream_fbdo, fullStreamPath.c_str());

            preferences.begin("pawfeeds-cam", false);
            preferences.clear();
            preferences.end();
            delay(500);
            ESP.restart();
        }
    }
}

void streamTimeoutCallback(bool timeout) {
  if (timeout) {
    Serial.println("[STREAM] Stream timed out. It will be restarted automatically.");
    streamActive = false;
  }
}

#define PART_BOUNDARY "12345678900000000000000000000000"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";
static const char* _FIRST_BOUNDARY = "--" PART_BOUNDARY "\r\n";

esp_err_t stream_handler(httpd_req_t *req){
  camera_fb_t * fb = NULL;
  esp_err_t res = ESP_OK;
  size_t _jpg_buf_len = 0;
  uint8_t * _jpg_buf = NULL;
  char * part_buf[64];
  bool is_first_frame = true;
  Serial.println("[STREAM HANDLER] Client connected.");
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) { return res;
  }
  
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache, no-store, must-revalidate");

  while (true) {
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.println("[STREAM HANDLER] ERROR: Camera frame capture failed.");
      res = ESP_FAIL;
      break;
    }
    
    _jpg_buf_len = fb->len;
    _jpg_buf = fb->buf;
    
    if(is_first_frame){
      res = httpd_resp_send_chunk(req, _FIRST_BOUNDARY, strlen(_FIRST_BOUNDARY));
      is_first_frame = false;
    } else {
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    }
    
    if (res == ESP_OK) {
      size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);
      res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);
    }

    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);
    }
    
    esp_camera_fb_return(fb);
    
    if (res != ESP_OK) {
      Serial.printf("[STREAM HANDLER] ERROR: Send chunk failed. Breaking loop.\n");
      break;
    }
    
    // ==========================================================
    // === STABILITY FIX: Change to 100ms for solid 10fps
    // ==========================================================
    delay(100); 
  }

  Serial.println("[STREAM HANDLER] Client disconnected.");
  return res;
}

void startCameraServer(){
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size = FRAMESIZE_VGA;
  config.jpeg_quality = 12;
  config.fb_count = 2; 

  config.fb_location = CAMERA_FB_IN_PSRAM;

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  httpd_handle_t stream_httpd = NULL;
  httpd_config_t server_config = HTTPD_DEFAULT_CONFIG();
  server_config.stack_size = 8192;
  httpd_uri_t stream_uri = {
      .uri       = "/stream",
      .method    = HTTP_GET,
      .handler   = stream_handler,
      .user_ctx  = NULL
  };
  if (httpd_start(&stream_httpd, &server_config) == ESP_OK) {
      httpd_register_uri_handler(stream_httpd, &stream_uri);
      Serial.print("[STREAM] Camera stream server started on Core 1 at http://");
      Serial.print(WiFi.localIP());
      Serial.println("/stream");
  }
}

// +++ This entire task runs on Core 1 +++
void camera_server_task(void *pvParameters) {
  Serial.println("[SYSTEM] Camera task started.");
  startCameraServer();
  // This task should not return. If it does, delete it.
  vTaskDelete(NULL);
}